---
title: "Functions"
order: 500
---

{{< include ../_static/_shared.qmd >}}

## Exposition

Now that we have discussed the major basic datatypes in R, we have a solid foundation with respect to the "nouns" of R, and it is a good time to turn to the R language's "verbs", functions.

I also like to think of functions as a type of creature that eats and processes data thereby providing a useful output. Think of yeast which "eat" sugar and process it into alcohol.

Functions, like creatures, also have an anatomy: a name, a mouth, and a body. Take the `c`{.r} function as an example that we learned about back in [Rcel, part 1](03-Rcel1.html). The name of the function is `c`{.r}. The mouth is the parentheses.

`c("e", "a", "t")`{.r}

The characters of the word "eat" are in this case the food, called arguments, for the function `c`{.r}.  They go in the mouth separated by commas (I like to think of them as teeth, but now, maybe Iâ€™m taking the analogy too far... ðŸ˜†).

Where is the body? R functions are generally shy and do not like to show off their body, so they hide it. However, if you call their name without offering food, they will show it to you as they turn to run away realizing you do not plan to offer them anything to eat. (Yes, the analogy is definitely getting thin ðŸ¤£.)

Try it now with the function named `c`{.r}. Just type `c`{.r} to see the body of the function.

```{webr}
#| caption: Exercise 1
#| exercise: e1
```

::: {.hint exercise="e1"}
::: {.callout-note collapse="false"}
Type just `c`{.r}. No parentheses, just `c`{.r}.
:::
:::

::: {.solution exercise="e1"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e1
#| solution: true
c
```
:::
:::

```{webr}
#| exercise: e1
#| check: true
gradethis::grade_this_code()
```

`c`{.r} has an unusually strange body. Trust me, dark magic is going on there so 
I suggest you just look away, unless you are into that sort of thing. Letâ€™s look
at a more typical function, `factor`{.r}, which you also met in 
[Rcel, part 1](03-Rcel1.html). How can you make `factor`{.r} show you its body? 

```{webr}
#| caption: Exercise 2
#| exercise: e2
```

::: {.hint exercise="e2"}
::: {.callout-note collapse="false"}
Type just `factor`{.r}. No parentheses, just `factor`{.r}.
:::
:::

::: {.solution exercise="e2"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e2
#| solution: true
factor
```
:::
:::

```{webr}
#| exercise: e2
#| check: true
gradethis::grade_this_code()
```

There is a lot going on there but look at the general structure. The keyword 
`function`{.r} followed by the mouth enclosed in parentheses `()`{.r} tells you some details about the foods this creature eats. Next, you see a section enclosed in
curly brackets `{}`{.r}: thatâ€™s the body. What is inside? Even now, I hope you can
appreciate that is the very R code we have been learning so far! The body of a
function holds a recipe of R code that can be reused to repeat a useful action.

If you thought `c`{.r} was odd, there are even functions that do not show their mouth without some coaxing. Can you think of one? What is an "action" you have taken on data that did not need parentheses? Think about it for a moment before continuing.

`<btn type="button" class="btn progress-continue">Continue</btn>`{=html}

How about the operators, like `+`, `*`, `>`, etc.? 
Can you believe that they are **ALL** functions? They are, but you have to know 
how to get these painfully shy creatures to show even their mouth.

```{=html}
<div>
To do so, you need to get bold by calling their name by using backticks. 
A backtick looks like <code class="sourceCode r"><span class="sc">`</span></code> 
and is not a single quote, i.e., <code class="sourceCode r"><span class="sc">'</span></code>. 
On the keyboard, you usually find the backtick on the same key as and under the 
tilde, <code class="sourceCode r"><span class="sc">~</span></code>, i.e.,
<kbd><div>~</div><div>`</div></kbd> on the upper left edge of your keyboard 
under the <kbd>Esc</kbd> key.
</div>
```

Try `` `*`(2, 2) ``{.r} to see `*`{.r} acting as a regular function.

```{webr}
#| caption: Exercise 3
#| exercise: e3
```


::: {.solution exercise="e3"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e3
#| solution: true
`*`(2, 2)
```
:::
:::

```{webr}
#| exercise: e3
#| check: true
gradethis::grade_this_code()
```

Can you guess how to get `*` to show you its body? 

```{webr}
#| caption: Exercise 4
#| exercise: e4
```

::: {.hint exercise="e4"}
::: {.callout-note collapse="false"}
Did you forget the backticks?
:::
:::

::: {.solution exercise="e4"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e4
#| solution: true
```
`*`{.r}
:::
:::

```{webr}
#| exercise: e4
#| check: true
gradethis::grade_this(
    if (.user_code == "`*`") {
        pass()
    } else {
        fail()
    }
)
```

All arguments have names, but you do not always need to use them. 
Look at the help for `factor`{.r} by typing `?factor`{.r}. The help is quite
detailed. After you run the command, scroll down and I'll give you some tips 
for walking through the help.

```{webr}
#| caption: Exercise 5
#| exercise: e5
```

::: {.solution exercise="e5"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e5
#| solution: true
?factor
```
:::
:::

```{webr}
#| exercise: e5
#| check: true
gradethis::grade_this_code()
```

Near the top of the help, youâ€™ll see the arguments for the function. In order, the names of the arguments for the `factor`{.r} function are `x`, `levels`, `labels`, `exclude`, `ordered`, and `nmax`. After many you will note an equals sign with something after it. These are the defaults for the argument if you do not specify them. However, just because `levels` does not have an explicit default in the list does not mean that it does not have one. If you read further into the help it says that `levels` does have a default value.

Since all values have a default, the function `factor`{.r} will return valid output even if run with no arguments, like this:

`factor()`{.r}

Try it now.

```{webr}
#| caption: Exercise 6
#| exercise: e6
```

::: {.solution exercise="e6"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e6
#| solution: true
factor()
```
:::
:::

```{webr}
#| exercise: e6
#| check: true
gradethis::grade_this_code()
```

R's response means that you created an empty (length 0) factor. On the other hand, `+` does not have default arguments, so if you type `` `+`() ``{.r} you'll get an error.  Try it now.

```{webr}
#| caption: Exercise 7
#| exercise: e7
```

::: {.solution exercise="e7"} 
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e7
#| solution: true
```
`` `+`() ``{.r}
:::
:::

```{webr}
#| exercise: e7
#| check: true
gradethis::grade_this(
    if (.user_code == "`+`()") {
        pass()
    } else {
        fail()
    }
)
```

So why the are the arguments named? The most important reason as you will learn in the next section is so that you can refer to the arguments by their name in the body of the function. A secondary use has to do with the way you call functions.

If you do not name the arguments when you call the function, R assumes that you are using them in order starting with the first listed. Names are useful when you need to skip an argument, want to be explicit about which argument something is, or if you are (or are afraid you might be) using them out of order.

Let's explore this. Start by creating a variable named `a` that contains the vector `c(1, 1, 2, 2)`{.r}.

```{webr}
#| caption: Exercise 8
#| exercise: e8
#| envir: env1
```

::: {.hint exercise="e8"}
::: {.callout-note collapse="false"}
Type just `a <- c(1, 1, 2, 2)`{.r}
:::
:::

::: {.solution exercise="e8"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e8
#| solution: true
a <- c(1, 1, 2, 2)
```
:::
:::

```{webr}
#| exercise: e8
#| check: true
gradethis::grade_this_code()
```

OK, when we use the `labels` argument to give them nice labels we have to type `factor(a, labels = c("M", "F"))`{.r}. Why? Because the second argument is not used and the third is named `labels`.

Look back at the help for `factor`{.r}. What is the name of the first argument according to the help file? Now specify that name even though you do not have to and run the same command: `factor(a, labels = c("M", "F"))`{.r}

```{webr}
#| caption: Exercise 9
#| exercise: e9
#| envir: env1
```

::: {.hint exercise="e9"}
::: {.callout-note collapse="false"}
Don't forget to add the correct tag to the first argument!
:::
:::

::: {.solution exercise="e9"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e9
#| solution: true
factor(x = a, labels = c("M", "F"))
```
:::
:::

```{webr}
#| exercise: e9
#| check: true
gradethis::grade_this_code()
```

Finally, put `labels`{.r} before the first argument!


```{webr}
#| caption: Exercise 10
#| exercise: e10
#| envir: env1
```

::: {.hint exercise="e10"}
:::{.callout-note collapse="false"}
Don't forget to tag `labels`{.r}!
:::
:::

::: {.solution exercise="e10"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e10
#| solution: true
factor(labels = c("M", "F"), x = a)
```
:::
:::

```{webr}
#| exercise: e10
#| check: true
gradethis::grade_this_code()
```

Now you know most everything you need to know about how to call R functions that already exist, but a lot of programming should be about writing your own functions.

Functions are your friend. Have you ever cut-and-paste a piece code to run it again after just tweaking it to run on slightly different data? Try not to do that, and instead use functions. Why?

* When you use functions, you encapsulate little pieces of logic in your program. It makes your code, and the thinking behind it, much easier to understand and modify. The code will also be shorter overall.

* If you cut and paste and realize you need to change something you have to do it everywhere and not make any mistakes, with a function you do it in one place: the function.

* You will also likely find your functions are useful in your next project, and a function is a good way to carry something useful from one project to another.

A major principle of programming is DRY which stands for "Donâ€™t Repeat Yourself". I might cut and paste something twice, but by the 3rd paste--- unless Iâ€™m seriously not going to do it again and then only if it is a very short (one line) piece of code---I am going to be trying to make a function out of it. This rule of not using the same code more than three times is also known as the "rule of three" in computer programming.

So how to write a function? Name it (via assignment with `<-`{.r}), use the keyword `function`{.r} followed by the mouth with a list of arguments. Then, write the R code inside the body. Use it just like any other R function. Use the name you chose for the argument in body of the function to work on the data that it will pass in. The names are NOT magic. You can pick anything you like and it will stand in for the object that is passed, just as if you assigned that data to that name outside the function. Type this example of a trivial function:

`add2 <- function(x) { x + 2 }`{.r}


```{webr}
#| caption: Exercise 11
#| exercise: e11
#| envir: env2
```

::: {.solution exercise="e11"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e11
#| solution: true
add2 <- function(x) { x + 2 }
```
:::
:::

```{webr}
#| exercise: e11
#| check: true
gradethis::grade_this_code()
```

Now try it out, like this: `add2(5)`

```{webr}
#| caption: Exercise 12
#| exercise: e12
#| envir: env2
```

::: {.solution exercise="e12"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e12
#| solution: true
add2(5)
```
:::
:::

```{webr}
#| exercise: e12
#| check: true
gradethis::grade_this_code()
```

And again, like this: `add2(2)`

```{webr}
#| caption: Exercise 13
#| exercise: e13
#| envir: env2
```

::: {.solution exercise="e13"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e13
#| solution: true
add2(2)
```
:::
:::

```{webr}
#| exercise: e13
#| check: true
gradethis::grade_this_code()
```

See how R takes your number, assigns it to `x`{.r}, adds `2`{.r} to `x`{.r}, and returns it.  It returns `x + 2`{.r} because it is the
last thing that is executed in the body of the function.  Let's make a
very slightly more complicated function.  Look at the function below.

```{webr}
#| caption: Example 1
#| edit: false
#| autorun: true
add2sub5 <- function(x) {
  x <- x + 2  #  here take x and add two to it, and save back to x
              #  if we don't save it somewhere the result will be "lost"
              #  (x is best to keep it simple)
  x - 5       #  subtract 5; since it's the last line the result will be returned
}
```

This second example function shows that within a function body you 
need to write R code just like you would at the console with each 
statement on a separate line. R returns the result of the last statement. 

The variables defined within the function are local to the function.
Changing their values as we did in add2sub5 does not change them outside the
function. Therefore, using functions also makes your programs much safer so you donâ€™t accidentally change something you did earlier in a
long program.

To see what I mean type and run `x <- 10`{.r}.

```{webr}
#| caption: Exercise 14
#| exercise: e14
#| envir: env3
```

::: {.solution exercise="e14"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e14
#| solution: true
x <- 10
```
:::
:::

```{webr}
#| exercise: e14
#| check: true
gradethis::grade_this_code()
```

Now try `add2sub5(10)`{.r}.

```{webr}
#| caption: Exercise 15
#| exercise: e15
#| envir: env3
```

::: {.solution exercise="e16"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e15
#| solution: true
add2sub5(10)
```
:::
:::

```{webr}
#| exercise: e15
#| check: true
gradethis::grade_this_code()
```

Did x change?  How can you take a peek?

```{webr}
#| caption: Exercise 16
#| exercise: e16
#| envir: env3
```

::: {.solution exercise="e17"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e16
#| solution: true
x
```
:::
:::

```{webr}
#| exercise: e16
#| check: true
gradethis::grade_this_code()
```

```{adm}
#| exercise: e16
#| type: open-on-pass
`<btn type="button" class="btn progress-continue">Continue</btn>`{=html}
```

Yep! `x`{.r} is still `10`{.r}.  So, functions help us protect our data because changes inside are "hidden" from the outside.  However, now
look at the function `addysub5`{.r} below.

```{webr}
#| caption: Example 2
#| autorun: true
#| edit: false
addysub5 <- function(x) {
  x <- x + y
  x - 5
}
```

Try to run `addysub5(10)`{.r}.

```{webr}
#| caption: Exercise 17
#| exercise: e17
```

::: {.solution exercise="e17"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e17
#| solution: true
```
`addysub5(10)`{.r} is an error because R can't find `y`{.r}.
:::
:::

```{webr}
#| exercise: e17
#| check: true
gradethis::grade_this(
    if (.user_code == "addysub5(10)") {
        pass()
    } else {
        fail()
    }
)
```

Now assign `y <- 5`{.r} so the function `addysub5` can find `y`.

```{webr}
#| caption: Exercise 18
#| exercise: e18
#| envir: global
```

::: {.solution exercise="e18"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e18
#| solution: true
y <- 5
```
:::
:::

```{webr}
#| exercise: e18
#| check: true
gradethis::grade_this_code()
```

Try to run `addysub5(10)`{.r} again.

```{webr}
#| caption: Exercise 19
#| exercise: e19
#| envir: global
```

::: {.solution exercise="e19"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e19
#| solution: true
addysub5(10)
```
:::
:::

```{webr}
#| exercise: e19
#| check: true
gradethis::grade_this_code()
```

Did `y` change? How can you take a peek?

```{webr}
#| caption: Exercise 20
#| exercise: e20
#| envir: global
```

::: {.solution exercise="e20"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e20
#| solution: true
y
```
:::
:::

```{webr}
#| exercise: e20
#| check: true
gradethis::grade_this_code()
```

If a variable is not specified by argument, then R has to search for it and 
looks outside the function to try to find it.  Once you assign
a number to `y`{.r}, then R can find it and will use it in the function.  
Avoiding this behavior isusually best; instead pass `y`{.r} as another argument.
However, occasionally this approach is the best solution to a problem.

# Experimentation

OK, now it is your turn to write a function from scratch. 
Your function must be named `add5`{.r} for the grading code to find it.
Guess what it should do?  Take one arguement (you can name that anything you like), 
add `5`{.r} to it, and return the result.

```{webr}
#| caption: Exercise 21
#| exercise: e21
```

::: {.solution exercise="e21"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e21
#| solution: true  
```

An example solution is:

```{.r}
add5 <- function(x) {
  x + 5
}
```
:::
:::

```{webr}
#| exercise: e21
#| check: true
gradethis::grade_this({
    if (!exists("add5", envir = .envir_result)) {
        fail("No function named add5 found")
    }
    out <- eval(parse(text = "add5(2)"), envir = .envir_result)
    if (out != 7) {
        fail("I expected add5(2) = 7 but got {out}")
    }
    out <- eval(parse(text = "add5(10)"), envir = .envir_result)
    if (out != 15) {
        fail("I expected add5(10) = 15 but got {out}")
    }
    pass()
})
```

Now write a function named `cube`{.r} that takes one argument (again you
can choose the name of the argument) and returns that number 
[cubed, i.e., raised to the 3rd power](https://en.wikipedia.org/wiki/Cube_(algebra)){target="_blank"}.

```{webr}
#| caption: Exercise 22
#| exercise: e22
```

::: {.solution exercise="e22"}
::: {.callout-note collapse="false"}
```{webr}
#| exercise: e22
#| solution: true  
```

Example solutions are:

```{.r}
cube <- function(x) {
  x ^ 3
}
```

or 

```{.r}
cube <- function(x) {
  x * x * x
}
```
:::
:::

```{webr}
#| exercise: e22
#| check: true
gradethis::grade_this({
    if (!exists("cube", envir = .envir_result)) {
        fail("No function named cube found")
    }
    out <- eval(parse(text = "cube(2)"), envir = .envir_result)
    if (out != 8) {
        fail("I expected cube(2) = 8 but got {out}")
    }
    out <- eval(parse(text = "cube(10)"), envir = .envir_result)
    if (out != 1000) {
        fail("I expected cube(10) = 1000 but got {out}")
    }
    pass()
})
```

```{adm}
#| exercise: e22
#| type: open-on-pass
Great job!  You have learned the basics of functions.  Between now and class
I want you think about how you could write a function that would return
two values instead of just one (hint: what data type could you return?)
```

## Evaluation

### Submit Your Assignment

Submit your assignment below.

```{adm}
#| type: progress-submit
```
::: {#adm-progress-submit}
```{webr}
#| autorun: true
.progress_submit("05-Functions", 22)
```
:::
