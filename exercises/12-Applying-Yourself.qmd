---
title: "Applying Yourself"
order: 1200
webr:
  cell-options:
    autorun: true
---

{{< include ../_static/_shared.qmd >}}

## Exposition

```{webr}
#| autorun: true
#| echo: false
load("_static/data/photoqual.rda")
```


### The `apply` family

R has a group of functions that all work in a similar fashion. Each of these
functions takes a function as an argument and applies that function
to each of the elements of one of its other arguments.  

These functions can replace most `for`{.r}-loops in R, and they were faster too 
historically.  The model function for this family of functions is: `apply`{.r}.  
(Shocking I know! ðŸ˜± Programmers are not that creative with names;
 nor should they be!)

Using the `apply`{.r} family functions is also more "R-like" than using `for`{.r}. 
That is to say, when you think in terms of these functions you are thinking more 
like an R programmer.  Just like different human languages have different figures 
of speech, idioms, and modes of thinking that characterize them, so do computer 
languages.

As we have discussed previously, R lends itself to functional types of 
programming idioms, one of which is called mapping. Mapping
means taking a function and "mapping" or "applying"
that function to every sub-element of vector, list, or array.  
So the `apply`{.r} family is a very "functional" programming idiom.

So, let's get started with the `apply`{.r} function.  The `apply`{.r} function works
on the rows or columns of an `data.frame`{.r} or `array`{.r}. We have not met 
an `array`{.r} before but they are essentially a `vector`{.r} that has 2 or more 
dimensions (e.g., a table has two dimensions) of all the same **atomic** data type.  
We will create one that contains 10,000 coin
flip experiments using 100 flips in each experiment.  
The function `rbinom`{.r} generates random binomially distributed
data.

```{webr}
set.seed(42)
rbinom(100, 1, 0.5)
```

Do the same thing 10,000 times and store the results in an array.

```{webr}
experiments <- replicate(10000, rbinom(100, 1, 0.5))
```

Look at the first few rows and columns and the dimensions of the array.

```{webr}
experiments[1:10, 1:10]
NROW(experiments)
NCOL(experiments)
dim(experiments)
```

So we have 10,000 experiments of 100 coin flips each.  Each expermient is in 
one column as we can see because there are 100 rows.  If we wanted to plot a 
histogram of how many heads were flipped (calling 1 as heads and 0 as tails) 
then we could  use the apply function to add each column up before calling 
`hist`{.r}.  In `apply`{.r} the second argument is the margin, i.e., which
dimension you want to apply the function over.  In this case, we want to apply
over the columns so we use `2`{.r} as the second argument.  The third argument is the
function to apply, in this case `sum`{.r}.

```{webr}
heads <- apply(experiments, 2, sum)
length(heads)
hist(heads)
mean(heads)
var(heads)
```

Glad that meets our expectations for the [mean and variance of
a binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution)!

### `lapply`

You probably recall from your basic statistics class that as the sample size 
increases our confidence in the mean increases. That means that the 
standard deviation / variance around the estimate of the mean decreases. 
Letâ€™s test that in R. We could do the following, but it is a lot of typing to do 
almost the same thing:

```{webr}
sd(replicate(1000, mean(rnorm(10,   100, 25)))) # 1000 experiments of n=10
sd(replicate(1000, mean(rnorm(100,  100, 25)))) # 1000 experiments of n=100
sd(replicate(1000, mean(rnorm(1000, 100, 25)))) # 1000 experiments of n=1000
```

What if we converted the second part of the experession to a function like this?
```{webr}
rsd <- function(n) sd(replicate(1000, mean(rnorm(n, 100, 25))))
```

Then, we could use the `lapply`{.r} function to complete these three lines of code
in one.  The `l`{.r} in `lapply`{.r} stands for "list" because it always returns 
a `list`{.r}.

```{webr}
lapply(c(10, 100, 1000), rsd)
```

Naming little utility functions like `rmean`{.r} can get annoying, so it turns
out that in R you can just use what are called **lambda** functions, i.e.,
unnamed functions.  So, you could do the above like this.

```{webr}
lapply(c(10, 100, 1000), function(n) sd(replicate(1000, mean(rnorm(n, 100, 25)))))
```

That way you do not have to name the function.  It is your call when
you name the function and when you use a lambda function instead.
Most advanced programmers would do the latter in this case
because it is short enough to comprehend easily, but either is absolutely
acceptable.

Now, let's return not only the variance but the mean.  Maybe here the 
function is complicated enough that it is worth naming separately for clarity:

```{webr}
rmv <- function(n) {
  r <- replicate(1000, mean(rnorm(n, 100, 25)))
  list(mean = mean(r), var = var(r))
}
lapply(c(10, 100, 1000), rmv)
```

Even more compact and adding one more power of 10.
```{webr}
lapply(10^(1:4), rmv)
```

This is less error prone, requires less typing, and is much more clear
than cutting and pasting a lot of code.

### `sapply`

When you return a single value you can use `sapply`{.r} to return a `vector`{.r} instead
of a `list`:
```{webr}
sapply(10^(1:3), rsd)
```

or an `array`{.r} when you return more than one:
```{webr}
sapply(10^(1:3), rmv)
```

The `s`{.r} in `sapply`{.r} stands for "simplify".  It tries to simplify the
result into a `vector`{.r} or `array`{.r} if possible.  If not, it returns a `list`{.r} 
like `lapply`{.r}.

### Are you feeling ragged yet?

You will quite frequently run into datasets like the following one I've already
loaded for you that contains information about the ocular photographs of patients,
each with a different number of photographs:

```{webr}
head(photoqual)
```

It may be tempting to run the `summary`{.r} function on the dataset, but you cannot 
do that in this case. You would get a weighted average of age by the number of 
photographs that the patient had taken, i.e., not the correct thing to report! 
Plus, the observations are not independent so your inferential statistics would be
all messed up.

The `tapply`{.r} function comes to the rescue because it allows a function to be applied to a 
**ragged array**, i.e., an unbalanced or an inconsistent number of observations 
in each set/array. So, what if you wanted to count how many photographs
each patient had on each eye?  Here's how you would do it.

```{webr}
tapply(photoqual$eye, photoqual$ptid, summary)
```

Pretty amazing, eh? I think this is even more amazing, it uses the `do.call`
function which takes a function name and applies it to a list which it takes
as its second argument.  So we can combine `do.call`{.r} with `tapply`{.r} to get a
nice table of the summaries for each patient.

```{webr}
do.call(rbind, tapply(photoqual$eye, photoqual$ptid, summary))
```

`do.call`{.r} is useful when you are trying to `apply`{.r} a function like `rbind`{.r} that
takes `...`{.r} as an argument (like `sum`{.r}, but not like `mean`{.r} - take a look
at the help for each of those functions).

By the way, another function called `aggregate`{.r} can do the same thing as the 
`do.call`{.r} + `tapply`{.r} combination in this case and is probably better in 
this instance because you probably want to keep the patient identifier associated 
with the response.

```{webr}
aggregate(photoqual$eye, photoqual['ptid'], function(x) summary(x))
```

However, `tapply`{.r} is a good way to capture a single variable 
for all patients in a dataset like this.  For example, here is the 
correct `summary`{.r} of the age for these patients.

Note that this

```{webr}
tapply(photoqual$age, photoqual$ptid, function(x) head(x, 1))
```

is equivalent to this.

```{webr}
tapply(photoqual$age, photoqual$ptid, head, 1)
```

Now do the summary.

```{webr}
summary(tapply(photoqual$age, photoqual$ptid, head, 1))
```

### You are not satisfied with just one argument?!?

There are several other `apply`{.r} family functions. Several are beyond the 
scope of this class, but as you advance in your R programming,
I want you to know others exist and to give you a brief taste of what
is possible with one of them. The major apply functions that we are "skipping"
are: `mapply`{.r}, `rapply`{.r}, `vapply`{.r}, and `eapply`{.r}.
I would recommend that if you want to learn more that you proceed in that
order. Here is a taste of `mapply` which uses each of the arguments after the 
function in order and walks through both simultaneously similar to a previous 
example.

```{webr}
mapply(rep, 1:4, 4:1)
```

Is not the same as

```{webr}
rep(1:4, 4:1)
```

but is the same as.

```{webr}
list(
  rep(1, 4),
  rep(2, 3),
  rep(3, 2),
  rep(4, 1)
)
```

Useful? You betcha! Is that obvious to you now? Probably not... but be on the 
lookout. The `apply`{.r} family can save you enormous amounts of time and can 
make you feel like you have a magic wand for data. ðŸª„

### Advanced tables

Now that you know the `apply`{.r} family take another look at the
[Advanced Table Example](09b-Advanced-Table-Example.qmd).

## Evaluation

Use `tapply` to determine the mean quality each patient had in each eye.  That
is calculate the mean of the quality for the first patient's right eye, the
first patient's left eye, etc.

Look at the help for `tapply` and realize that you can use more than one factor
as the `INDEX`.  Note that the help says it has to be a `list`.  How do you make
a `list` again? 

```{webr}
#| exercise: e1
#| caption: Exercise
tapply(______)
```

::: { .solution exercise="e1" }
```{webr}
#| exercise: e1
#| solution: true
tapply(photoqual$quality, list(photoqual$ptid, photoqual$eye), mean)
```
:::

```{webr}
#| exercise: e1
#| check: true
gradethis::grade_this_code()
```

```{adm}
#| exercise: e1
#| type: open-on-pass
Think about why some values are missing in your result?
```


### Submit Your Assignment

```{adm}
#| type: progress-submit
```
::: {#adm-progress-submit}
```{webr}
#| autorun: true
.progress_submit("12-Applying-Yourself", 1)
```
:::
