{
  "hash": "b3d5d245b3faf5c96db36132002cca66",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Rcel, Part 1\"\norder: 300\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\n###########################################################\n# if you edit this section note there is an `r` block below too\n.course_id <- readLines(\"_static/data/course_id.txt\")\n.assignment_ids <- dget(\"_static/data/assignment_ids.txt\")\n.canvas_link <- function(a) glue::glue(\"https://canvas.emory.edu/courses/{.course_id}/assignments/{.assignment_ids[{a}]}\")\n############################################################\n.webr_progress <- data.frame(label = character(), user_code = character(), solution_code = character(), result = logical())\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    res <- gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n    .webr_progress <<- rbind(\n      .webr_progress,\n      data.frame(\n        label = label,\n        user_code = user_code,\n        solution_code = solution_code,\n        result = res$correct\n      )\n    )\n    res\n  }\n})\n.csv_data_uri <- function(df) {\n  enc_csv <- base64enc::base64encode(\n    charToRaw(\n      paste(\n        capture.output(\n          write.csv(df)),\n          collapse = \"\\n\")\n    )\n  )\n  glue::glue(\"data:text/csv;base64,{enc_csv}\")\n}\n.save_restore_progress <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::tags$a(\n      download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n      href = .csv_data_uri(df),\n      htmltools::tags$button(\n          #onClick = \"this.classList.add('clicked');\",\n          class = \"btn progress-submit\",\n          \"Save progress\",\n          .noWS = \"outside\"\n      )\n    ),\n    htmltools::tags$label(\n      `for` = \"restore-file-input\",\n      type = \"button\",\n      id = \"restore-progress-button\",\n      class = \"btn progress-submit btn-quarto\",\n      onClick = \"restore_listener();\",\n      \"Restore progress\"\n    ),\n    htmltools::tags$input(\n      type = \"file\",\n      id = \"restore-file-input\",\n      style = \"display: none\",\n      accept = \".csv\"\n    )\n  )\n}\n.steps_to_submit <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::p(\n      htmltools::strong(\"Steps to submit:\")\n    ),\n    htmltools::tags$ol(\n        htmltools::tags$li(\n        \"Save your work to your device by clicking: \",\n        htmltools::tags$a(\n            download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n            href = .csv_data_uri(df),\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Download\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"Go to related Canvas assignment (note this will open a new tab or window and you may need to login) by clicking:\",\n        htmltools::tags$a(\n            href = .canvas_link(assignment_name),\n            target = \"_blank\",\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Open Canvas Assignment\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"On the page that just opened find and click on a button\",\n        \"that looks like this in the upper right corner:\",\n        htmltools::tags$img(\n            src = \"../_static/canvas_start_assignment.png\",\n            alt = \"Start Assignment Button\",\n            style = \"max-width: 200px; border: 1px solid black; margin-left: 1em;\"\n        )\n        ),\n        htmltools::tags$li(\n        htmltools::p(\"After you click you should see the following:\"),\n        htmltools::tags$img(\n            src = \"../_static/canvas_submission.png\",\n            alt = \"Submit Assignment Image\",\n            style = \"max-width: 400px; border: 1px solid black; margin-left: 5em;\"\n        ),\n        htmltools::p(\n            \"Either drag the file you saved in the first step or click \",\n            \"\\\"Choose a file to upload\\\" under the rocket drawing \",\n            \"to find the file.\"\n        )\n        ),\n        htmltools::tags$li(\n        \"Finally, click the \\\"Submit Assignment\\\" button.\"\n        )\n    )\n  )\n}\n.progress_submit <- function(assignment_name, n_exercises, progress_obj = .webr_progress) {\n  all <- as.character(1:n_exercises)\n  done <- gsub(\"e\", \"\", sort(unique(progress_obj$label[progress_obj$result])))\n  todo <- setdiff(all, done)\n  collapse_runs <- function(x) {\n    x <- as.integer(x)\n    out <- character()\n    for (i in seq_along(x)) {\n      if (i == 1) {\n        run_start <- run_end <- x[i]\n        next\n      }\n      if (x[i] == run_end + 1) {\n        run_end <- x[i]\n      } else {\n        if (run_start == run_end) {\n          out <- c(out, as.character(run_start))\n        } else {\n          out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n        }\n        run_start <- run_end <- x[i]\n      }\n    }\n    if (run_start == run_end) {\n      out <- c(out, as.character(run_start))\n    } else {\n      out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n    }\n    out\n  }\n  collapse_nums <- function(x) {\n    x <- collapse_runs(x)\n    if (length(x) == 1) {\n      return(x)\n    } else if (length(x) == 2) {\n      return(glue::glue(\"{x[1]} and {x[2]}\"))\n    } else {\n      return(glue::glue_collapse(x, \", \", last = \", and \"))\n    }\n  }\n  if (length(todo) > 0) {\n    htmltools::div(\n      htmltools::tags$p(\n        glue::glue(\n          \"Before you can submit you still need correctly complete exercises \",\n          collapse_nums(todo),\n          \".\"\n          ),\n          style = \"color: red; font-weight: bold;\"\n      ),\n      .save_restore_progress(assignment_name)\n    )\n  } else {\n    htmltools::div(\n      htmltools::p(\n        \"All done! You can submit now!\",\n        style = \"color: green; font-weight: bold;\"\n      ),\n    .steps_to_submit(assignment_name)\n    )\n  }\n}\n```\n:::\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Exposition\n\n### Introduction\n\nOnce you learn R well, you will likely find that you do not tend to use spreadsheets like Microsoft Excel as much for common tasks that you might have previously done in spreadsheet software. We will learn about a spreadsheet-like structure, `data.frame`{.r}, that develops naturally as we work with the composite data types `vector`{.r}, \n`factor`{.r}, and `list`{.r}.\n\nThese are foundational exercises so do not just type mindlessly at the R console to get the \"right\" answer, but also try to be sure you understand what is happening.\n\nThis lesson will only cover the `vector`{.r} and `factor`{.r} data types.\n\n### Vectors\n\nA `vector`{.r} is constructed using a function simply called `c`{.r}. Note that `c` is lower case which, as you now know, matters because R is a case-sensitive language. If you type a capital, or upper case, \"C\" instead of lower case \"c\" then R will *not* know what you mean.\nThis seems a minor inconvenience when you realize that \"c\" stands for \"combine\"\nor \"concatenate.\"  Let's thank the designers of R for giving this important\nand commonly used function a short name!\n\nTry it out! Type and run `c(1, 2, 3)`{.r}.\n\n\n::: {.cell caption='Exercise 1' exercise='e1'}\n```{webr}\n#| caption: Exercise 1\n#| exercise: e1\n```\n:::\n\n\n::: { .hint exercise=\"e1\"}\n::: { .callout-note collapse=\"false\"}\nJust type: `c(1, 2, 3)`{.r}\n:::\n:::\n\n::: { .solution exercise=\"e1\"}\n::: { .callout-note collapse=\"false\"}\n\n::: {.cell exercise='e1' solution='true'}\n```{webr}\n#| exercise: e1\n#| solution: true\nc(1, 2, 3)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e1' check='true'}\n```{webr}\n#| exercise: e1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nA convenient way to make a `vector`{.r} of consecutive numbers is to use a colon, \ni.e, `:`{.r}, between them them like `1:5`{.r}.\n\nTry it now.\n\n\n::: {.cell caption='Exercise 2' exercise='e2'}\n```{webr}\n#| caption: Exercise 2\n#| exercise: e2\n```\n:::\n\n\n\n::: { .hint exercise=\"e2\"}\n::: { .callout-note collapse=\"false\"}\nType `1:5`{.r}\n:::\n:::\n\n::: { .solution exercise=\"e2\"}\n::: { .callout-note collapse=\"false\"}\n\n::: {.cell exercise='e2' solution='true'}\n```{webr}\n#| exercise: e2\n#| solution: true\n1:5\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e2' check='true'}\n```{webr}\n#| exercise: e2\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nA `vector`{.r} can only be made of values from the same atomic type.  So, we can\nalso make a `vector`{.r} of a different type, e.g., \na character `vector`{.r} like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"a\", \"b\", \"c\")\n```\n:::\n\n\nNow, you try to make a *logical* `vector`{.r}.\n\n\n::: {.cell caption='Exercise 3' exercise='e3'}\n```{webr}\n#| caption: Exercise 3\n#| exercise: e3\n```\n:::\n\n\n::: { .hint exercise=\"e3\"}\n::: { .callout-note collapse=\"false\"}\nUse the function c, TRUE, and FALSE.\n:::\n:::\n\n::: { .solution exercise=\"e3\"}\n::: { .callout-note collapse=\"false\"}\nAn example solution would be `c(TRUE, FALSE, FALSE)`{.r}\n\n::: {.cell exercise='e3' solution='true'}\n```{webr}\n#| exercise: e3\n#| solution: true\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e3' check='true'}\n```{webr}\n#| exercise: e3\n#| check: true\ngradethis::grade_this(\n    if(is.logical(.user) && length(.user) > 1) {\n        pass()\n    } else {\n        fail()\n    }\n)\n```\n:::\n\n\n\nThe `is.numeric`{.r}, `is.character`{.r}, and `is.logical`{.r} functions that you learned about in the [Atomic Data Types](02-Atomic-Data-Types.html) work on a `vector`{.r} too.\nType one of those functions with a `vector`{.r}---e.g., `is.numeric(c(\"a\", \"b\"))`---below,\nthink about what R will respond, and then run it.\n\n\n\n::: {.cell caption='Exercise 4' exercise='e4'}\n```{webr}\n#| caption: Exercise 4\n#| exercise: e4\n```\n:::\n\n\n::: { .hint exercise=\"e4\"}\n::: { .callout-note collapse=\"false\"}\nUse the function `c`{.r} and one of these functions: `is.numeric`{.r}, \n`is.character`{.r}, or `is.logical`{.r}.\n:::\n:::\n\n::: { .solution exercise=\"e4\"}\n::: { .callout-note collapse=\"false\"}\n\n::: {.cell exercise='e4' solution='true'}\n```{webr}\n#| exercise: e4\n#| solution: true\n```\n:::\n\n\nLots of valid choices here! For example:\n\n::: {.cell}\n\n```{.r .cell-code}\nis.logical(c(TRUE, FALSE, TRUE))\nis.character(c(\"a\", \"b\", \"c\"))\nis.numeric(c(1, 2, 3))\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e4' check='true'}\n```{webr}\n#| exercise: e4\n#| check: true\ngradethis::grade_this(\n    if(grepl(\"is\\\\.(logical|character|numeric)\\\\( *c\", .user_code)) {\n        pass()\n    } else {\n        fail()\n    }\n)\n```\n:::\n\n\nBy now you are probably pretty tired of typing things like `c(TRUE,TRUE,TRUE,FALSE,TRUE)`{.r} and wonder if there is a way you could save things like that for later use. There is! It is called *assignment*.\n\nWe can assign a name to represent a `vector`{.r} (or any R object). We do this using the `<-`{.r} operator (that is made of two characters, the less than symbol, `<`, and a hyphen, `-` with no space between). Think of it as an arrow that directs the value on the right-hand side of `<-`{.r} into the name on the left-hand side.\n\nType `x <- c(TRUE, TRUE, TRUE, FALSE, TRUE)` below and run it.\n\n\n::: {.cell caption='Exercise 5' exercise='e5' envir='env1'}\n```{webr}\n#| caption: Exercise 5\n#| exercise: e5\n#| envir: env1\n```\n:::\n\n\n::: { .hint exercise=\"e5\"}\n::: { .callout-note collapse=\"false\"}\nType `x <- c(TRUE, TRUE, TRUE, FALSE, TRUE)`{.r}\n:::\n:::\n\n::: { .solution exercise=\"e5\"}\n::: { .callout-note collapse=\"false\"}\n\n::: {.cell exercise='e5' solution='true'}\n```{webr}\n#| exercise: e5\n#| solution: true\nx <- c(TRUE, TRUE, TRUE, FALSE, TRUE)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e5' check='true'}\n```{webr}\n#| exercise: e5\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow you can use the name `x`{.r} in place of the `vector`{.r}.\nType `is.logical(x)` below and run it.\n\n\n::: {.cell caption='Exercise 6' exercise='e6' envir='env1'}\n```{webr}\n#| caption: Exercise 6\n#| exercise: e6\n#| envir: env1\n```\n:::\n\n\n::: { .hint exercise=\"e6\"}\n::: { .callout-note collapse=\"false\"}\nType `is.logical(x)`{.r}\n:::\n:::\n\n::: { .solution exercise=\"e6\"}\n::: { .callout-note collapse=\"false\"}\n\n::: {.cell exercise='e6' solution='true'}\n```{webr}\n#| exercise: e6\n#| solution: true\nis.logical(x)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e6' check='true'}\n```{webr}\n#| exercise: e6\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nThe name `x`{.r} is just one of a nearly infinite number of names, but R does have some rules for valid names:\n\nA valid name can only consist of:\n\n- letters,\n- numbers,\n- the dot or period character (`.`), and\n- the underscore or underline character (`_`),\n\nAnd it can only start with:\n\n- a letter, or\n- the dot not followed by a number.\n\nYou can see what the name `x`{.r} contains by typing that name. Try it now, just type `x`{.r}.\n\n\n::: {.cell caption='Exercise 7' exercise='e7' envir='env1'}\n```{webr}\n#| caption: Exercise 7\n#| exercise: e7\n#| envir: env1\n```\n:::\n\n\n::: { .hint exercise=\"e7\"}\n::: { .callout-note collapse=\"false\"}\nType `x`{.r}\n:::\n:::\n\n::: { .solution exercise=\"e7\"}\n::: { .callout-note collapse=\"false\"}\n\n::: {.cell exercise='e7' solution='true'}\n```{webr}\n#| exercise: e7\n#| solution: true\nx\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e7' check='true'}\n```{webr}\n#| exercise: e7\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhen you name something the same thing, it is replaced. Type and run\n`x <- c(1, 2, 3)`{.r}\n\n\n::: {.cell caption='Exercise 8' exercise='e8' envir='env1'}\n```{webr}\n#| caption: Exercise 8\n#| exercise: e8\n#| envir: env1\n```\n:::\n\n\n::: { .hint exercise=\"e8\"}\n::: { .callout-note collapse=\"false\"}\nType `x <- c(1, 2, 3)`{.r}\n:::\n:::\n\n::: { .solution exercise=\"e8\"}\n::: { .callout-note collapse=\"false\"}\n\n::: {.cell exercise='e8' solution='true'}\n```{webr}\n#| exercise: e8\n#| solution: true\nx <- c(1, 2, 3)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e8' check='true'}\n```{webr}\n#| exercise: e8\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow look at what is in the variable `x`{.r}.\n\n\n::: {.cell caption='Exercise 9' exercise='e9' envir='env1'}\n```{webr}\n#| caption: Exercise 9\n#| exercise: e9\n#| envir: env1\n```\n:::\n\n\n\n::: {.cell exercise='e9' solution='true'}\n```{webr}\n#| exercise: e9\n#| solution: true\nx\n```\n:::\n\n\n\n::: {.cell exercise='e9' check='true'}\n```{webr}\n#| exercise: e9\n#| check: true\ngradethis::grade_this(\n  if (.user_code == \"x\" && identical(.user, c(1, 2, 3))) {\n    pass()\n    } else {\n    fail()\n  }\n)\n```\n:::\n\n\nAs you can see, `x`{.r} now contains that new numeric `vector`{.r}.  The name can stand in\nfor the object that is assigned to it anywhere that the object can be used,\neven in assignment.  See that now by assigning `x`{.r} to `y`{.r}.\n\n\n::: {.cell caption='Exercise 10' exercise='e10' envir='env1'}\n```{webr}\n#| caption: Exercise 10\n#| exercise: e10\n#| envir: env1\n```\n:::\n\n\n::: { .hint exercise=\"e10\"}\n::: { .callout-note collapse=\"false\"}\nType `y <- x`{.r}\n:::\n:::\n\n::: { .solution exercise=\"e10\"}\n::: { .callout-note collapse=\"false\"}\n\n::: {.cell exercise='e10' solution='true'}\n```{webr}\n#| exercise: e10\n#| solution: true\ny <- x\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e10' check='true'}\n```{webr}\n#| exercise: e10\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nFinally, you cannot use one of the reserved words as names. You have seen a\nfew of these already, e.g., `TRUE`{.r} and `NaN`{.r}\n\nIt could really wreck havoc on R if you could change the value of those names.  \nTry to assign `5`{.r} to the name `TRUE`{.r}.\n\n\n::: {.cell caption='Exercise 11' exercise='e11' envir='env1'}\n```{webr}\n#| caption: Exercise 11\n#| exercise: e11\n#| envir: env1\n```\n:::\n\n\n::: { .hint exercise=\"e11\"}\n::: { .callout-note collapse=\"false\"}\nType `TRUE <- 5`{.r}\n:::\n:::\n\n::: { .solution exercise=\"e11\"}\n::: { .callout-note collapse=\"false\"}\n\n::: {.cell exercise='e11' solution='true'}\n```{webr}\n#| exercise: e11\n#| solution: true\n```\n:::\n\nHopefully, the error makes a little sense.  You have an invalid left-hand\nside (i.e., TRUE) for the assignment.\n:::\n:::\n\n\n\n::: {.cell exercise='e11' check='true'}\n```{webr}\n#| exercise: e11\n#| check: true\ngradethis::grade_this(\n    if (.user_code == \"TRUE <- 5\") {\n        pass()\n    } else {\n        fail()\n    }\n)\n```\n:::\n\n\n\n::: {.cell exercise='e11' type='open-solution-on-pass'}\n```{adm}\n#| exercise: e11\n#| type: open-solution-on-pass\n```\n:::\n\n\n### Factors\n\nOK, it is time to turn to a new data type, i.e., `factor`{.r}.\n\nA `factor`{.r} is similar to a `vector`{.r}, but is used to represent a nominal or\nordinal variable. This allows R to automatically give you back the right\nstatistics for something that is not numeric. For now, we will use the\nsummary function to show the difference.  Let's start by assigning the\nfollowing to `c(1, 1, 2, 3, 1)`{.r} to `x`{.r}.\n\n\n::: {.cell caption='Exercise 12' exercise='e12' envir='env2'}\n```{webr}\n#| caption: Exercise 12\n#| exercise: e12\n#| envir: env2\n```\n:::\n\n\n::: { .hint exercise=\"e12\"}\n::: { .callout-note collapse=\"false\"}\nType `x <- c(1, 1, 2, 3, 1)`{.r}\n:::\n:::\n\n::: { .solution exercise=\"e12\"}\n::: { .callout-note collapse=\"false\"}\n\n::: {.cell exercise='e12' solution='true'}\n```{webr}\n#| exercise: e12\n#| solution: true\nx <- c(1, 1, 2, 3, 1)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e12' check='true'}\n```{webr}\n#| exercise: e12\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow let's create a `factor`{.r} version of `x`{.r} in the variable `y`{.r} like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- factor(x)\n```\n:::\n\n\n\n\n::: {.cell caption='Exercise 13' exercise='e13' envir='env2'}\n```{webr}\n#| caption: Exercise 13\n#| exercise: e13\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e13\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e13' solution='true'}\n```{webr}\n#| exercise: e13\n#| solution: true\ny <- factor(x)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e13' check='true'}\n```{webr}\n#| exercise: e13\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow apply the summary function to `x`, like this: `summary(x)`{.r}\n\n\n::: {.cell caption='Exercise 14' exercise='e14' envir='env2'}\n```{webr}\n#| caption: Exercise 14\n#| exercise: e14\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e14\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e14' solution='true'}\n```{webr}\n#| exercise: e14\n#| solution: true\nsummary(x)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e14' check='true'}\n```{webr}\n#| exercise: e14\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::: {.solution exercise=\"e14b\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e14' solution='true'}\n```{webr}\n#| exercise: e14\n#| solution: true\ny <- factor(x)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e14' check='true'}\n```{webr}\n#| exercise: e14\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow apply the `summary`{.r} function to `x`{.r}:\n\nDo the same for `y`.\n\n\n::: {.cell caption='Exercise 15' exercise='e15' envir='env2'}\n```{webr}\n#| caption: Exercise 15\n#| exercise: e15\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e15\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e15' solution='true'}\n```{webr}\n#| exercise: e15\n#| solution: true\nsummary(y)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e15' check='true'}\n```{webr}\n#| exercise: e15\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nThat last output may be a little confusing at first, but notice that it is a\ntype of table with the different values in the first row and the number of\nelements in the factor that take that value in the second row.  So you see in\nthe first instance, `x`{.r} is a numeric `vector`{.r} and R provides summary statistics\nthat make sense for a continuous variable.  In the second case, `y`{.r} is a\n`factor`{.r} that R understands to be categorical.\n\nWhen you give the values labels, as you often will, it can be much easier to\nunderstand the summary of a `factor`{.r}. Make a new `factor`{.r} from `x` called `state`\nusing labels, like this (you don't have to always create new names, we\ncould just have chosen to write over `y`, but for now let's do it this way):\n`state <- factor(x, labels = c(\"GA\", \"FL\", \"AL\"))`{.r}\n\n\n::: {.cell caption='Exercise 16' exercise='e16' envir='env2'}\n```{webr}\n#| caption: Exercise 16\n#| exercise: e16\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e16\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e16' solution='true'}\n```{webr}\n#| exercise: e16\n#| solution: true\nstate <- factor(x, labels = c(\"GA\", \"FL\", \"AL\"))\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e16' check='true'}\n```{webr}\n#| exercise: e16\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow make a summary of `state`{.r} and examine the results.\n\n\n::: {.cell exercise='e17' caption='Exercise 17' envir='env2'}\n```{webr}\n#| exercise: e17\n#| caption: Exercise 17\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e17\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e17' solution='true'}\n```{webr}\n#| exercise: e17\n#| solution: true\nsummary(state)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e17' check='true'}\n```{webr}\n#| exercise: e17\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nThe `labels = c(...)`{.r} is a named argument to the `factor`{.r} function. The argument's name is `labels` and the argument itself is the `c(...)`{.r}. Notice the `=`{.r} sign that connects the name to the argument. We will discuss this more in the future. For now, just use this exact syntax if you need to label a numeric `vector`{.r} when creating a `factor`{.r}.\n\nNote that the labels match the order of the values if you use numbers, not the order they appear in the `vector`{.r} you convert to a `factor`{.r}. Try the following by putting `x`{.r} in a different order even though it represents the same data:\n\n`x <- c(2, 3, 1, 1, 1)`{.r}\n\n\n::: {.cell caption='Exercise 18' exercise='e18' envir='env2'}\n```{webr}\n#| caption: Exercise 18\n#| exercise: e18\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e18\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e18' solution='true'}\n```{webr}\n#| exercise: e18\n#| solution: true\nx <- c(2, 3, 1, 1, 1)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e18' check='true'}\n```{webr}\n#| exercise: e18\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow create a `factor`{.r} named `state`{.r} from `x`{.r} in the same way as before using `labels = c(\"GA\", \"FL\", \"AL\")`{.r}.\n\n\n::: {.cell caption='Exercise 19' exercise='e19' envir='env2'}\n```{webr}\n#| caption: Exercise 19\n#| exercise: e19\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e19\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e19' solution='true'}\n```{webr}\n#| exercise: e19\n#| solution: true\nstate <- factor(x, labels = c(\"GA\", \"FL\", \"AL\"))\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e19' check='true'}\n```{webr}\n#| exercise: e19\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nExamine the summary of `state`{.r}.\n\n\n::: {.cell caption='Exercise 20' exercise='e20' envir='env2'}\n```{webr}\n#| caption: Exercise 20\n#| exercise: e20\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e20\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e20' solution='true'}\n```{webr}\n#| exercise: e20\n#| solution: true\nsummary(state)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e20' check='true'}\n```{webr}\n#| exercise: e20\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\nAs you can see the results turned out exactly the same even though the numeric `vector`{.r} was in a different order. You can also use a character `vector`{.r} to create a `factor`{.r}, try this: `state <- factor(c(\"GA\", \"GA\", \"FL\", \"AL\", \"GA\"))`{.r}\n\n\n::: {.cell caption='Exercise 21' exercise='e21' envir='env2'}\n```{webr}\n#| caption: Exercise 21\n#| exercise: e21\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e21\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e21' solution='true'}\n```{webr}\n#| exercise: e21\n#| solution: true\nstate <- factor(c(\"GA\", \"GA\", \"FL\", \"AL\", \"GA\"))\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e21' check='true'}\n```{webr}\n#| exercise: e21\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nExamine the summary of `state`{.r} again.\n\n\n::: {.cell caption='Exercise 22' exercise='e22' envir='env2'}\n```{webr}\n#| caption: Exercise 22\n#| exercise: e22\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e22\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e22' solution='true'}\n```{webr}\n#| exercise: e22\n#| solution: true\nsummary(state)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e22' check='true'}\n```{webr}\n#| exercise: e22\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow they are alphabetically ordered. Thus, how the data is structured can have an influence on the order of the names in a `factor`{.r}. There are many other ways to influence the order and we will likely see those as we progress.\n\n### Extracting Elements\n\nWhen you want to extract a specific element from a `vector`{.r} or `factor`{.r}, you use square brackets (i.e., `[ ]`) and the index (the number) of the element within the data structure. So to get the fifth element of `x`{.r} from before, which was `c(2, 3, 1, 1, 1)`{.r}, you'd type `x[5]`{.r}.\n\nTry it now.\n\n\n::: {.cell caption='Exercise 23' exercise='e23' envir='env2'}\n```{webr}\n#| caption: Exercise 23\n#| exercise: e23\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e23\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e23' solution='true'}\n```{webr}\n#| exercise: e23\n#| solution: true\nx[5]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e23' check='true'}\n```{webr}\n#| exercise: e23\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nAs you can see we got `1`{.r} which was the fifth element of the `vector`{.r} `x`{.r}. So since `x`{.r} is `c(2, 3, 1, 1, 1)`{.r}. What would you do to get R to return `3`{.r} instead of `1`{.r}?\n\n\n::: {.cell caption='Exercise 24' exercise='e24' envir='env2'}\n```{webr}\n#| caption: Exercise 24\n#| exercise: e24\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e24\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e24' solution='true'}\n```{webr}\n#| exercise: e24\n#| solution: true\nx[2]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e24' check='true'}\n```{webr}\n#| exercise: e24\n#| check: true\ngradethis::grade_this_code()\n\n```\n:::\n\n\nJust like with names we can use these extract values anywhere they would be valid. Try `x[2] + x[5]`{.r}.\n\n\n::: {.cell caption='Exercise 25' exercise='e25' envir='env2'}\n```{webr}\n#| caption: Exercise 25\n#| exercise: e25\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e25\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e25' solution='true'}\n```{webr}\n#| exercise: e25\n#| solution: true\nx[2] + x[5]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e25' check='true'}\n```{webr}\n#| exercise: e25\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhat if you want a new `vector`{.r} of a subset of the values in the `vector`{.r} `x`{.r}? We need our trusty friend `c`{.r} again, try `x[c(2, 5)]`{.r}.\n\n\n::: {.cell caption='Exercise 26' exercise='e26' envir='env2'}\n```{webr}\n#| caption: Exercise 26\n#| exercise: e26\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e26\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e26' solution='true'}\n```{webr}\n#| exercise: e26\n#| solution: true\nx[c(2, 5)]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e26' check='true'}\n```{webr}\n#| exercise: e26\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nSo you see that returns a new `vector`{.r} of length two made up of the second and fifth elements of `x`{.r}. The square bracket notation also works on a `factor`{.r}. Now extract the third element of `state`{.r}.\n\n\n::: {.cell caption='Exercise 27' exercise='e27' envir='env2'}\n```{webr}\n#| caption: Exercise 27\n#| exercise: e27\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e27\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e27' solution='true'}\n```{webr}\n#| exercise: e27\n#| solution: true\nstate[3]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e27' check='true'}\n```{webr}\n#| exercise: e27\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow is where you'll see how `vector`{.r} operations in R are a lot like using\nfunctions on columns in Excel.  Keep in mind `x`{.r} is `c(2, 3, 1, 1, 1)`{.r}.  \nType `x * 2`{.r}.\n\n\n::: {.cell exercise='e28' caption='Exercise 28' envir='env2'}\n```{webr}\n#| exercise: e28\n#| caption: Exercise 28\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e28\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e28' solution='true'}\n```{webr}\n#| exercise: e28\n#| solution: true\nx * 2\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e28' check='true'}\n```{webr}\n#| exercise: e28\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nHow about `x < 2`{.r}?\n\n\n::: {.cell caption='Exercise 29' exercise='e29' envir='env2'}\n```{webr}\n#| caption: Exercise 29\n#| exercise: e29\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e29\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e29' solution='true'}\n```{webr}\n#| exercise: e29\n#| solution: true\nx < 2\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e29' check='true'}\n```{webr}\n#| exercise: e29\n#| check: true\ngradethis::grade_this_code()\n\n```\n:::\n\n\nSee how it applies the expression elementwise? \n\nYou can also apply operators to two `vector`{.r}'s of the same length in which case the resulting `vector`{.r} will be the result of the operator applied to the first element of each `vector`{.r}, then the second element of each `vector`{.r}, and so on. Remember `x`{.r} is `c(2, 3, 1, 1, 1)`{.r} and try:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx - c(1, 0, 1, 0, 1)\n```\n:::\n\n\n\n::: {.cell caption='Exercise 30' exercise='e30' envir='env2'}\n```{webr}\n#| caption: Exercise 30\n#| exercise: e30\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e30\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e30' solution='true'}\n```{webr}\n#| exercise: e30\n#| solution: true\nx - c(1, 0, 1, 0, 1)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e30' check='true'}\n```{webr}\n#| exercise: e30\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nYou can even use a `vector`{.r} that is shorter than the other. The shorter one will be recycled, try:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 0, 1, 0, 1, 0) + c(0, 1)\n```\n:::\n\n\n\n::: {.cell caption='Exercise 31' exercise='e31'}\n```{webr}\n#| caption: Exercise 31\n#| exercise: e31\n```\n:::\n\n\n::: {.solution exercise=\"e31\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e31' solution='true'}\n```{webr}\n#| exercise: e31\n#| solution: true\nc(1, 0, 1, 0, 1, 0) + c(0, 1)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e31' check='true'}\n```{webr}\n#| exercise: e31\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nHowever, you will get a warning if the shorter `vector`{.r} is not a multiple of the longer `vector`{.r} because this is usually unintentional, and it most often indicates a bug in your program. In this case, though, it works the way we expect, try `c(1, 0, 1, 0, 1) + c(0, 1)`{.r}.\n\n\n::: {.cell caption='Exercise 32' exercise='e32'}\n```{webr}\n#| caption: Exercise 32\n#| exercise: e32\n```\n:::\n\n\n::: {.solution exercise=\"e32\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e32' solution='true'}\n```{webr}\n#| exercise: e32\n#| solution: true\nc(1, 0, 1, 0, 1) + c(0, 1)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e32' check='true'}\n```{webr}\n#| exercise: e32\n#| check: true\ngradethis::grade_this_code()\n\n```\n:::\n\n\n::: {.callout-note}\nA warning is issued by a program when it can continue executing, but is not sure it did what you were expecting it to do. A warning does not rise to the level of an error which is something that the program cannot recover from.\n:::\n\n## Experimentation\n\nLet's make a really long `vector`{.r} of sequential integers from 5 to 123.\n\n\n::: {.cell caption='Exercise 33' exercise='e33'}\n```{webr}\n#| caption: Exercise 33\n#| exercise: e33\n```\n:::\n\n\n::: {.solution exercise=\"e33\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e33' solution='true'}\n```{webr}\n#| exercise: e33\n#| solution: true\n5:123\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e33' check='true'}\n```{webr}\n#| exercise: e33\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::: { .callout-note}\nExamine the output. Now that you know how to extract elements from a `vector`{.r} with square brackets, can you explain why R has been printing [1] at the beginning of the output all this time and why R is now printing other numbers between the square brackets ([ ])? Come ready to discuss in class.\n:::\n\nI bet you can also guess what function can test if something is a `vector`{.r} (of any type). Find out if a `factor`{.r} is also a `vector`{.r} by trying that function on `state`{.r}.\n\n\n::: {.cell caption='Exercise 34' exercise='e34' envir='env2'}\n```{webr}\n#| caption: Exercise 34\n#| exercise: e34\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e34\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e34' solution='true'}\n```{webr}\n#| exercise: e34\n#| solution: true\nis.vector(state)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e34' check='true'}\n```{webr}\n#| exercise: e34\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nRemember that I said that a vector can only be made from the same atomic type? \n\nTry typing and running `c(TRUE, 0, FALSE, 3)`{.r} and look at R's response.\n\n\n::: {.cell caption='Experiment'}\n```{webr}\n#| caption: Experiment\n```\n:::\n\n\nNow, try typing and running `c(\"a\", 3, TRUE)`{.r} and likewise examine\nR's response.\n\n\n::: {.cell caption='Experiment'}\n```{webr}\n#| caption: Experiment\n```\n:::\n\n\nWhat is R doing? Why does this always work? Come to class prepared to discuss.\nNow submit your assignment!\n\n## Evaluation\n\n### Submit Your Assignment\n\n\n::: {.cell type='progress-submit'}\n```{adm}\n#| type: progress-submit\n```\n:::\n\n::: {#adm-progress-submit}\n\n::: {.cell autorun='true'}\n```{webr}\n#| autorun: true\n.progress_submit(\"03-Rcel1\", 34)\n```\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}