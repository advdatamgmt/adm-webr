{
  "hash": "b3c303b09a7c2cf76b160d21613fabf0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functions\"\norder: 500\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\n###########################################################\n# if you edit this section note there is an `r` block below too\n.course_id <- readLines(\"_static/data/course_id.txt\")\n.assignment_ids <- dget(\"_static/data/assignment_ids.txt\")\n.canvas_link <- function(a) glue::glue(\"https://canvas.emory.edu/courses/{.course_id}/assignments/{.assignment_ids[{a}]}\")\n############################################################\n.webr_progress <- data.frame(label = character(), user_code = character(), solution_code = character(), result = logical())\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    res <- gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n    .webr_progress <<- rbind(\n      .webr_progress,\n      data.frame(\n        label = label,\n        user_code = user_code,\n        solution_code = solution_code,\n        result = res$correct\n      )\n    )\n    res\n  }\n})\n.csv_data_uri <- function(df) {\n  enc_csv <- base64enc::base64encode(\n    charToRaw(\n      paste(\n        capture.output(\n          write.csv(df)),\n          collapse = \"\\n\")\n    )\n  )\n  glue::glue(\"data:text/csv;base64,{enc_csv}\")\n}\n.save_restore_progress <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::tags$a(\n      download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n      href = .csv_data_uri(df),\n      htmltools::tags$button(\n          #onClick = \"this.classList.add('clicked');\",\n          class = \"btn progress-submit\",\n          \"Save progress\",\n          .noWS = \"outside\"\n      )\n    ),\n    htmltools::tags$label(\n      `for` = \"restore-file-input\",\n      type = \"button\",\n      id = \"restore-progress-button\",\n      class = \"btn progress-submit btn-quarto\",\n      onClick = \"restore_listener();\",\n      \"Restore progress\"\n    ),\n    htmltools::tags$input(\n      type = \"file\",\n      id = \"restore-file-input\",\n      style = \"display: none\",\n      accept = \".csv\"\n    )\n  )\n}\n.steps_to_submit <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::p(\n      htmltools::strong(\"Steps to submit:\")\n    ),\n    htmltools::tags$ol(\n        htmltools::tags$li(\n        \"Save your work to your device by clicking: \",\n        htmltools::tags$a(\n            download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n            href = .csv_data_uri(df),\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Download\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"Go to related Canvas assignment (note this will open a new tab or window and you may need to login) by clicking:\",\n        htmltools::tags$a(\n            href = .canvas_link(assignment_name),\n            target = \"_blank\",\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Open Canvas Assignment\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"On the page that just opened find and click on a button\",\n        \"that looks like this in the upper right corner:\",\n        htmltools::tags$img(\n            src = \"../_static/canvas_start_assignment.png\",\n            alt = \"Start Assignment Button\",\n            style = \"max-width: 200px; border: 1px solid black; margin-left: 1em;\"\n        )\n        ),\n        htmltools::tags$li(\n        htmltools::p(\"After you click you should see the following:\"),\n        htmltools::tags$img(\n            src = \"../_static/canvas_submission.png\",\n            alt = \"Submit Assignment Image\",\n            style = \"max-width: 400px; border: 1px solid black; margin-left: 5em;\"\n        ),\n        htmltools::p(\n            \"Either drag the file you saved in the first step or click \",\n            \"\\\"Choose a file to upload\\\" under the rocket drawing \",\n            \"to find the file.\"\n        )\n        ),\n        htmltools::tags$li(\n        \"Finally, click the \\\"Submit Assignment\\\" button.\"\n        )\n    )\n  )\n}\n.progress_submit <- function(assignment_name, n_exercises, progress_obj = .webr_progress) {\n  all <- as.character(1:n_exercises)\n  done <- gsub(\"e\", \"\", sort(unique(progress_obj$label[progress_obj$result])))\n  todo <- setdiff(all, done)\n  collapse_runs <- function(x) {\n    x <- as.integer(x)\n    out <- character()\n    for (i in seq_along(x)) {\n      if (i == 1) {\n        run_start <- run_end <- x[i]\n        next\n      }\n      if (x[i] == run_end + 1) {\n        run_end <- x[i]\n      } else {\n        if (run_start == run_end) {\n          out <- c(out, as.character(run_start))\n        } else {\n          out <- c(out, glue::glue(\"{run_start}â€“{run_end}\"))\n        }\n        run_start <- run_end <- x[i]\n      }\n    }\n    if (run_start == run_end) {\n      out <- c(out, as.character(run_start))\n    } else {\n      out <- c(out, glue::glue(\"{run_start}â€“{run_end}\"))\n    }\n    out\n  }\n  collapse_nums <- function(x) {\n    x <- collapse_runs(x)\n    if (length(x) == 1) {\n      return(x)\n    } else if (length(x) == 2) {\n      return(glue::glue(\"{x[1]} and {x[2]}\"))\n    } else {\n      return(glue::glue_collapse(x, \", \", last = \", and \"))\n    }\n  }\n  if (length(todo) > 0) {\n    htmltools::div(\n      htmltools::tags$p(\n        glue::glue(\n          \"Before you can submit you still need correctly complete exercises \",\n          collapse_nums(todo),\n          \".\"\n          ),\n          style = \"color: red; font-weight: bold;\"\n      ),\n      .save_restore_progress(assignment_name)\n    )\n  } else {\n    htmltools::div(\n      htmltools::p(\n        \"All done! You can submit now!\",\n        style = \"color: green; font-weight: bold;\"\n      ),\n    .steps_to_submit(assignment_name)\n    )\n  }\n}\n```\n:::\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Exposition\n\nNow that we have discussed the major basic datatypes in R, we have a solid foundation with respect to the \"nouns\" of R, and it is a good time to turn to the R language's \"verbs\", functions.\n\nI also like to think of functions as a type of creature that eats and processes data thereby providing a useful output. Think of yeast which \"eat\" sugar and process it into alcohol.\n\nFunctions, like creatures, also have an anatomy: a name, a mouth, and a body. Take the `c`{.r} function as an example that we learned about back in [Rcel, part 1](03-Rcel1.html). The name of the function is `c`{.r}. The mouth is the parentheses.\n\n`c(\"e\", \"a\", \"t\")`{.r}\n\nThe characters of the word \"eat\" are in this case the food, called arguments, for the function `c`{.r}.  They go in the mouth separated by commas (I like to think of them as teeth, but now, maybe Iâ€™m taking the analogy too far... ðŸ˜†).\n\nWhere is the body? R functions are generally shy and do not like to show off their body, so they hide it. However, if you call their name without offering food, they will show it to you as they turn to run away realizing you do not plan to offer them anything to eat. (Yes, the analogy is definitely getting thin ðŸ¤£.)\n\nTry it now with the function named `c`{.r}. Just type `c`{.r} to see the body of the function.\n\n\n::: {.cell caption='Exercise 1' exercise='e1'}\n```{webr}\n#| caption: Exercise 1\n#| exercise: e1\n```\n:::\n\n\n::: {.hint exercise=\"e1\"}\n::: {.callout-note collapse=\"false\"}\nType just `c`{.r}. No parentheses, just `c`{.r}.\n:::\n:::\n\n::: {.solution exercise=\"e1\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e1' solution='true'}\n```{webr}\n#| exercise: e1\n#| solution: true\nc\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e1' check='true'}\n```{webr}\n#| exercise: e1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n`c`{.r} has an unusually strange body. Trust me, dark magic is going on there so \nI suggest you just look away, unless you are into that sort of thing. Letâ€™s look\nat a more typical function, `factor`{.r}, which you also met in \n[Rcel, part 1](03-Rcel1.html). How can you make `factor`{.r} show you its body? \n\n\n::: {.cell caption='Exercise 2' exercise='e2'}\n```{webr}\n#| caption: Exercise 2\n#| exercise: e2\n```\n:::\n\n\n::: {.hint exercise=\"e2\"}\n::: {.callout-note collapse=\"false\"}\nType just `factor`{.r}. No parentheses, just `factor`{.r}.\n:::\n:::\n\n::: {.solution exercise=\"e2\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e2' solution='true'}\n```{webr}\n#| exercise: e2\n#| solution: true\nfactor\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e2' check='true'}\n```{webr}\n#| exercise: e2\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nThere is a lot going on there but look at the general structure. The keyword \n`function`{.r} followed by the mouth enclosed in parentheses `()`{.r} tells you some details about the foods this creature eats. Next, you see a section enclosed in\ncurly brackets `{}`{.r}: thatâ€™s the body. What is inside? Even now, I hope you can\nappreciate that is the very R code we have been learning so far! The body of a\nfunction holds a recipe of R code that can be reused to repeat a useful action.\n\nIf you thought `c`{.r} was odd, there are even functions that do not show their mouth without some coaxing. Can you think of one? What is an \"action\" you have taken on data that did not need parentheses? Think about it for a moment before continuing.\n\n`<btn type=\"button\" class=\"btn progress-continue\">Continue</btn>`{=html}\n\nHow about the operators, like `+`, `*`, `>`, etc.? \nCan you believe that they are **ALL** functions? They are, but you have to know \nhow to get these painfully shy creatures to show even their mouth.\n\n```{=html}\n<div>\nTo do so, you need to get bold by calling their name by using backticks. \nA backtick looks like <code class=\"sourceCode r\"><span class=\"sc\">`</span></code> \nand is not a single quote, i.e., <code class=\"sourceCode r\"><span class=\"sc\">'</span></code>. \nOn the keyboard, you usually find the backtick on the same key as and under the \ntilde, <code class=\"sourceCode r\"><span class=\"sc\">~</span></code>, i.e.,\n<kbd><div>~</div><div>`</div></kbd> on the upper left edge of your keyboard \nunder the <kbd>Esc</kbd> key.\n</div>\n```\n\nTry `` `*`(2, 2) ``{.r} to see `*`{.r} acting as a regular function.\n\n\n::: {.cell caption='Exercise 3' exercise='e3'}\n```{webr}\n#| caption: Exercise 3\n#| exercise: e3\n```\n:::\n\n\n\n::: {.solution exercise=\"e3\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e3' solution='true'}\n```{webr}\n#| exercise: e3\n#| solution: true\n`*`(2, 2)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e3' check='true'}\n```{webr}\n#| exercise: e3\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nCan you guess how to get `*` to show you its body? \n\n\n::: {.cell caption='Exercise 4' exercise='e4'}\n```{webr}\n#| caption: Exercise 4\n#| exercise: e4\n```\n:::\n\n\n::: {.hint exercise=\"e4\"}\n::: {.callout-note collapse=\"false\"}\nDid you forget the backticks?\n:::\n:::\n\n::: {.solution exercise=\"e4\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e4' solution='true'}\n```{webr}\n#| exercise: e4\n#| solution: true\n```\n:::\n\n`*`{.r}\n:::\n:::\n\n\n::: {.cell exercise='e4' check='true'}\n```{webr}\n#| exercise: e4\n#| check: true\ngradethis::grade_this(\n    if (.user_code == \"`*`\") {\n        pass()\n    } else {\n        fail()\n    }\n)\n```\n:::\n\n\nAll arguments have names, but you do not always need to use them. \nLook at the help for `factor`{.r} by typing `?factor`{.r}. The help is quite\ndetailed. After you run the command, scroll down and I'll give you some tips \nfor walking through the help.\n\n\n::: {.cell caption='Exercise 5' exercise='e5'}\n```{webr}\n#| caption: Exercise 5\n#| exercise: e5\n```\n:::\n\n\n::: {.solution exercise=\"e5\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e5' solution='true'}\n```{webr}\n#| exercise: e5\n#| solution: true\n?factor\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e5' check='true'}\n```{webr}\n#| exercise: e5\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNear the top of the help, youâ€™ll see the arguments for the function. In order, the names of the arguments for the `factor`{.r} function are `x`, `levels`, `labels`, `exclude`, `ordered`, and `nmax`. After many you will note an equals sign with something after it. These are the defaults for the argument if you do not specify them. However, just because `levels` does not have an explicit default in the list does not mean that it does not have one. If you read further into the help it says that `levels` does have a default value.\n\nSince all values have a default, the function `factor`{.r} will return valid output even if run with no arguments, like this:\n\n`factor()`{.r}\n\nTry it now.\n\n\n::: {.cell caption='Exercise 6' exercise='e6'}\n```{webr}\n#| caption: Exercise 6\n#| exercise: e6\n```\n:::\n\n\n::: {.solution exercise=\"e6\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e6' solution='true'}\n```{webr}\n#| exercise: e6\n#| solution: true\nfactor()\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e6' check='true'}\n```{webr}\n#| exercise: e6\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nR's response means that you created an empty (length 0) factor. On the other hand, `+` does not have default arguments, so if you type `` `+`() ``{.r} you'll get an error.  Try it now.\n\n\n::: {.cell caption='Exercise 7' exercise='e7'}\n```{webr}\n#| caption: Exercise 7\n#| exercise: e7\n```\n:::\n\n\n::: {.solution exercise=\"e7\"} \n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e7' solution='true'}\n```{webr}\n#| exercise: e7\n#| solution: true\n```\n:::\n\n`` `+`() ``{.r}\n:::\n:::\n\n\n::: {.cell exercise='e7' check='true'}\n```{webr}\n#| exercise: e7\n#| check: true\ngradethis::grade_this(\n    if (.user_code == \"`+`()\") {\n        pass()\n    } else {\n        fail()\n    }\n)\n```\n:::\n\n\nSo why the are the arguments named? The most important reason as you will learn in the next section is so that you can refer to the arguments by their name in the body of the function. A secondary use has to do with the way you call functions.\n\nIf you do not name the arguments when you call the function, R assumes that you are using them in order starting with the first listed. Names are useful when you need to skip an argument, want to be explicit about which argument something is, or if you are (or are afraid you might be) using them out of order.\n\nLet's explore this. Start by creating a variable named `a` that contains the vector `c(1, 1, 2, 2)`{.r}.\n\n\n::: {.cell caption='Exercise 8' exercise='e8' envir='env1'}\n```{webr}\n#| caption: Exercise 8\n#| exercise: e8\n#| envir: env1\n```\n:::\n\n\n::: {.hint exercise=\"e8\"}\n::: {.callout-note collapse=\"false\"}\nType just `a <- c(1, 1, 2, 2)`{.r}\n:::\n:::\n\n::: {.solution exercise=\"e8\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e8' solution='true'}\n```{webr}\n#| exercise: e8\n#| solution: true\na <- c(1, 1, 2, 2)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e8' check='true'}\n```{webr}\n#| exercise: e8\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nOK, when we use the `labels` argument to give them nice labels we have to type `factor(a, labels = c(\"M\", \"F\"))`{.r}. Why? Because the second argument is not used and the third is named `labels`.\n\nLook back at the help for `factor`{.r}. What is the name of the first argument according to the help file? Now specify that name even though you do not have to and run the same command: `factor(a, labels = c(\"M\", \"F\"))`{.r}\n\n\n::: {.cell caption='Exercise 9' exercise='e9' envir='env1'}\n```{webr}\n#| caption: Exercise 9\n#| exercise: e9\n#| envir: env1\n```\n:::\n\n\n::: {.hint exercise=\"e9\"}\n::: {.callout-note collapse=\"false\"}\nDon't forget to add the correct tag to the first argument!\n:::\n:::\n\n::: {.solution exercise=\"e9\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e9' solution='true'}\n```{webr}\n#| exercise: e9\n#| solution: true\nfactor(x = a, labels = c(\"M\", \"F\"))\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e9' check='true'}\n```{webr}\n#| exercise: e9\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nFinally, put `labels`{.r} before the first argument!\n\n\n\n::: {.cell caption='Exercise 10' exercise='e10' envir='env1'}\n```{webr}\n#| caption: Exercise 10\n#| exercise: e10\n#| envir: env1\n```\n:::\n\n\n::: {.hint exercise=\"e10\"}\n:::{.callout-note collapse=\"false\"}\nDon't forget to tag `labels`{.r}!\n:::\n:::\n\n::: {.solution exercise=\"e10\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e10' solution='true'}\n```{webr}\n#| exercise: e10\n#| solution: true\nfactor(labels = c(\"M\", \"F\"), x = a)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e10' check='true'}\n```{webr}\n#| exercise: e10\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow you know most everything you need to know about how to call R functions that already exist, but a lot of programming should be about writing your own functions.\n\nFunctions are your friend. Have you ever cut-and-paste a piece code to run it again after just tweaking it to run on slightly different data? Try not to do that, and instead use functions. Why?\n\n* When you use functions, you encapsulate little pieces of logic in your program. It makes your code, and the thinking behind it, much easier to understand and modify. The code will also be shorter overall.\n\n* If you cut and paste and realize you need to change something you have to do it everywhere and not make any mistakes, with a function you do it in one place: the function.\n\n* You will also likely find your functions are useful in your next project, and a function is a good way to carry something useful from one project to another.\n\nA major principle of programming is DRY which stands for \"Donâ€™t Repeat Yourself\". I might cut and paste something twice, but by the 3rd paste--- unless Iâ€™m seriously not going to do it again and then only if it is a very short (one line) piece of code---I am going to be trying to make a function out of it. This rule of not using the same code more than three times is also known as the \"rule of three\" in computer programming.\n\nSo how to write a function? Name it (via assignment with `<-`{.r}), use the keyword `function`{.r} followed by the mouth with a list of arguments. Then, write the R code inside the body. Use it just like any other R function. Use the name you chose for the argument in body of the function to work on the data that it will pass in. The names are NOT magic. You can pick anything you like and it will stand in for the object that is passed, just as if you assigned that data to that name outside the function. Type this example of a trivial function:\n\n`add2 <- function(x) { x + 2 }`{.r}\n\n\n\n::: {.cell caption='Exercise 11' exercise='e11' envir='env2'}\n```{webr}\n#| caption: Exercise 11\n#| exercise: e11\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e11\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e11' solution='true'}\n```{webr}\n#| exercise: e11\n#| solution: true\nadd2 <- function(x) { x + 2 }\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e11' check='true'}\n```{webr}\n#| exercise: e11\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow try it out, like this: `add2(5)`\n\n\n::: {.cell caption='Exercise 12' exercise='e12' envir='env2'}\n```{webr}\n#| caption: Exercise 12\n#| exercise: e12\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e12\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e12' solution='true'}\n```{webr}\n#| exercise: e12\n#| solution: true\nadd2(5)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e12' check='true'}\n```{webr}\n#| exercise: e12\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nAnd again, like this: `add2(2)`\n\n\n::: {.cell caption='Exercise 13' exercise='e13' envir='env2'}\n```{webr}\n#| caption: Exercise 13\n#| exercise: e13\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e13\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e13' solution='true'}\n```{webr}\n#| exercise: e13\n#| solution: true\nadd2(2)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e13' check='true'}\n```{webr}\n#| exercise: e13\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nSee how R takes your number, assigns it to `x`{.r}, adds `2`{.r} to `x`{.r}, and returns it.  It returns `x + 2`{.r} because it is the\nlast thing that is executed in the body of the function.  Let's make a\nvery slightly more complicated function.  Look at the function below.\n\n\n::: {.cell caption='Example 1' edit='false' autorun='true'}\n```{webr}\n#| caption: Example 1\n#| edit: false\n#| autorun: true\nadd2sub5 <- function(x) {\n  x <- x + 2  #  here take x and add two to it, and save back to x\n              #  if we don't save it somewhere the result will be \"lost\"\n              #  (x is best to keep it simple)\n  x - 5       #  subtract 5; since it's the last line the result will be returned\n}\n```\n:::\n\n\nThis second example function shows that within a function body you \nneed to write R code just like you would at the console with each \nstatement on a separate line. R returns the result of the last statement. \n\nThe variables defined within the function are local to the function.\nChanging their values as we did in add2sub5 does not change them outside the\nfunction. Therefore, using functions also makes your programs much safer so you donâ€™t accidentally change something you did earlier in a\nlong program.\n\nTo see what I mean type and run `x <- 10`{.r}.\n\n\n::: {.cell caption='Exercise 14' exercise='e14' envir='env3'}\n```{webr}\n#| caption: Exercise 14\n#| exercise: e14\n#| envir: env3\n```\n:::\n\n\n::: {.solution exercise=\"e14\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e14' solution='true'}\n```{webr}\n#| exercise: e14\n#| solution: true\nx <- 10\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e14' check='true'}\n```{webr}\n#| exercise: e14\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow try `add2sub5(10)`{.r}.\n\n\n::: {.cell caption='Exercise 15' exercise='e15' envir='env3'}\n```{webr}\n#| caption: Exercise 15\n#| exercise: e15\n#| envir: env3\n```\n:::\n\n\n::: {.solution exercise=\"e16\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e15' solution='true'}\n```{webr}\n#| exercise: e15\n#| solution: true\nadd2sub5(10)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e15' check='true'}\n```{webr}\n#| exercise: e15\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nDid x change?  How can you take a peek?\n\n\n::: {.cell caption='Exercise 16' exercise='e16' envir='env3'}\n```{webr}\n#| caption: Exercise 16\n#| exercise: e16\n#| envir: env3\n```\n:::\n\n\n::: {.solution exercise=\"e17\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e16' solution='true'}\n```{webr}\n#| exercise: e16\n#| solution: true\nx\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e16' check='true'}\n```{webr}\n#| exercise: e16\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n::: {.cell exercise='e16' type='open-on-pass'}\n```{adm}\n#| exercise: e16\n#| type: open-on-pass\n`<btn type=\"button\" class=\"btn progress-continue\">Continue</btn>`{=html}\n```\n:::\n\n\nYep! `x`{.r} is still `10`{.r}.  So, functions help us protect our data because changes inside are \"hidden\" from the outside.  However, now\nlook at the function `addysub5`{.r} below.\n\n\n::: {.cell caption='Example 2' autorun='true' edit='false'}\n```{webr}\n#| caption: Example 2\n#| autorun: true\n#| edit: false\naddysub5 <- function(x) {\n  x <- x + y\n  x - 5\n}\n```\n:::\n\n\nTry to run `addysub5(10)`{.r}.\n\n\n::: {.cell caption='Exercise 17' exercise='e17'}\n```{webr}\n#| caption: Exercise 17\n#| exercise: e17\n```\n:::\n\n\n::: {.solution exercise=\"e17\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e17' solution='true'}\n```{webr}\n#| exercise: e17\n#| solution: true\n```\n:::\n\n`addysub5(10)`{.r} is an error because R can't find `y`{.r}.\n:::\n:::\n\n\n::: {.cell exercise='e17' check='true'}\n```{webr}\n#| exercise: e17\n#| check: true\ngradethis::grade_this(\n    if (.user_code == \"addysub5(10)\") {\n        pass()\n    } else {\n        fail()\n    }\n)\n```\n:::\n\n\nNow assign `y <- 5`{.r} so the function `addysub5` can find `y`.\n\n\n::: {.cell caption='Exercise 18' exercise='e18' envir='global'}\n```{webr}\n#| caption: Exercise 18\n#| exercise: e18\n#| envir: global\n```\n:::\n\n\n::: {.solution exercise=\"e18\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e18' solution='true'}\n```{webr}\n#| exercise: e18\n#| solution: true\ny <- 5\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e18' check='true'}\n```{webr}\n#| exercise: e18\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nTry to run `addysub5(10)`{.r} again.\n\n\n::: {.cell caption='Exercise 19' exercise='e19' envir='global'}\n```{webr}\n#| caption: Exercise 19\n#| exercise: e19\n#| envir: global\n```\n:::\n\n\n::: {.solution exercise=\"e19\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e19' solution='true'}\n```{webr}\n#| exercise: e19\n#| solution: true\naddysub5(10)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e19' check='true'}\n```{webr}\n#| exercise: e19\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nDid `y` change? How can you take a peek?\n\n\n::: {.cell caption='Exercise 20' exercise='e20' envir='global'}\n```{webr}\n#| caption: Exercise 20\n#| exercise: e20\n#| envir: global\n```\n:::\n\n\n::: {.solution exercise=\"e20\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e20' solution='true'}\n```{webr}\n#| exercise: e20\n#| solution: true\ny\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e20' check='true'}\n```{webr}\n#| exercise: e20\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nIf a variable is not specified by argument, then R has to search for it and \nlooks outside the function to try to find it.  Once you assign\na number to `y`{.r}, then R can find it and will use it in the function.  \nAvoiding this behavior isusually best; instead pass `y`{.r} as another argument.\nHowever, occasionally this approach is the best solution to a problem.\n\n## Experimentation\n\nOK, now it is your turn to write a function from scratch. \nYour function must be named `add5`{.r} for the grading code to find it.\nGuess what it should do?  Take one arguement (you can name that anything you like), \nadd `5`{.r} to it, and return the result.\n\n\n::: {.cell caption='Exercise 21' exercise='e21'}\n```{webr}\n#| caption: Exercise 21\n#| exercise: e21\n```\n:::\n\n\n::: {.solution exercise=\"e21\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e21' solution='true'}\n```{webr}\n#| exercise: e21\n#| solution: true  \n```\n:::\n\n\nAn example solution is:\n\n```{.r}\nadd5 <- function(x) {\n  x + 5\n}\n```\n:::\n:::\n\n\n::: {.cell exercise='e21' check='true'}\n```{webr}\n#| exercise: e21\n#| check: true\ngradethis::grade_this({\n    if (!exists(\"add5\", envir = .envir_result)) {\n        fail(\"No function named add5 found\")\n    }\n    out <- eval(parse(text = \"add5(2)\"), envir = .envir_result)\n    if (out != 7) {\n        fail(\"I expected add5(2) = 7 but got {out}\")\n    }\n    out <- eval(parse(text = \"add5(10)\"), envir = .envir_result)\n    if (out != 15) {\n        fail(\"I expected add5(10) = 15 but got {out}\")\n    }\n    pass()\n})\n```\n:::\n\n\nNow write a function named `cube`{.r} that takes one argument (again you\ncan choose the name of the argument) and returns that number \n[cubed, i.e., raised to the 3rd power](https://en.wikipedia.org/wiki/Cube_(algebra)){target=\"_blank\"}.\n\n\n::: {.cell caption='Exercise 22' exercise='e22'}\n```{webr}\n#| caption: Exercise 22\n#| exercise: e22\n```\n:::\n\n\n::: {.solution exercise=\"e22\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e22' solution='true'}\n```{webr}\n#| exercise: e22\n#| solution: true  \n```\n:::\n\n\nExample solutions are:\n\n```{.r}\ncube <- function(x) {\n  x ^ 3\n}\n```\n\nor \n\n```{.r}\ncube <- function(x) {\n  x * x * x\n}\n```\n:::\n:::\n\n\n::: {.cell exercise='e22' check='true'}\n```{webr}\n#| exercise: e22\n#| check: true\ngradethis::grade_this({\n    if (!exists(\"cube\", envir = .envir_result)) {\n        fail(\"No function named cube found\")\n    }\n    out <- eval(parse(text = \"cube(2)\"), envir = .envir_result)\n    if (out != 8) {\n        fail(\"I expected cube(2) = 8 but got {out}\")\n    }\n    out <- eval(parse(text = \"cube(10)\"), envir = .envir_result)\n    if (out != 1000) {\n        fail(\"I expected cube(10) = 1000 but got {out}\")\n    }\n    pass()\n})\n```\n:::\n\n\n\n::: {.cell exercise='e22' type='open-on-pass'}\n```{adm}\n#| exercise: e22\n#| type: open-on-pass\nGreat job!  You have learned the basics of functions.  Between now and class\nI want you think about how you could write a function that would return\ntwo values instead of just one (hint: what data type could you return?)\n```\n:::\n\n\n## Evaluation\n\n### Submit Your Assignment\n\nSubmit your assignment below.\n\n\n::: {.cell type='progress-submit'}\n```{adm}\n#| type: progress-submit\n```\n:::\n\n::: {#adm-progress-submit}\n\n::: {.cell autorun='true'}\n```{webr}\n#| autorun: true\n.progress_submit(\"05-Functions\", 22)\n```\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}