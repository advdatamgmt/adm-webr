{
  "hash": "0924b820fc3240f76b92f09f7414b57d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Atomic Data Types\"\norder: 200\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\n###########################################################\n# if you edit this section note there is an `r` block below too\n.course_id <- readLines(\"_static/data/course_id.txt\")\n.assignment_ids <- dget(\"_static/data/assignment_ids.txt\")\n.canvas_link <- function(a) glue::glue(\"https://canvas.emory.edu/courses/{.course_id}/assignments/{.assignment_ids[{a}]}\")\n############################################################\n.webr_progress <- data.frame(label = character(), user_code = character(), solution_code = character(), result = logical())\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    res <- gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n    .webr_progress <<- rbind(\n      .webr_progress,\n      data.frame(\n        label = label,\n        user_code = user_code,\n        solution_code = solution_code,\n        result = res$correct\n      )\n    )\n    res\n  }\n})\n.csv_data_uri <- function(df) {\n  enc_csv <- base64enc::base64encode(\n    charToRaw(\n      paste(\n        capture.output(\n          write.csv(df)),\n          collapse = \"\\n\")\n    )\n  )\n  glue::glue(\"data:text/csv;base64,{enc_csv}\")\n}\n.save_restore_progress <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::tags$a(\n      download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n      href = .csv_data_uri(df),\n      htmltools::tags$button(\n          #onClick = \"this.classList.add('clicked');\",\n          class = \"btn progress-submit\",\n          \"Save progress\",\n          .noWS = \"outside\"\n      )\n    ),\n    htmltools::tags$label(\n      `for` = \"restore-file-input\",\n      type = \"button\",\n      id = \"restore-progress-button\",\n      class = \"btn progress-submit btn-quarto\",\n      onClick = \"restore_listener();\",\n      \"Restore progress\"\n    ),\n    htmltools::tags$input(\n      type = \"file\",\n      id = \"restore-file-input\",\n      style = \"display: none\",\n      accept = \".csv\"\n    )\n  )\n}\n.steps_to_submit <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::p(\n      htmltools::strong(\"Steps to submit:\")\n    ),\n    htmltools::tags$ol(\n        htmltools::tags$li(\n        \"Save your work to your device by clicking: \",\n        htmltools::tags$a(\n            download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n            href = .csv_data_uri(df),\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Download\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"Go to related Canvas assignment (note this will open a new tab or window and you may need to login) by clicking:\",\n        htmltools::tags$a(\n            href = .canvas_link(assignment_name),\n            target = \"_blank\",\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Open Canvas Assignment\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"On the page that just opened find and click on a button\",\n        \"that looks like this in the upper right corner:\",\n        htmltools::tags$img(\n            src = \"../_static/canvas_start_assignment.png\",\n            alt = \"Start Assignment Button\",\n            style = \"max-width: 200px; border: 1px solid black; margin-left: 1em;\"\n        )\n        ),\n        htmltools::tags$li(\n        htmltools::p(\"After you click you should see the following:\"),\n        htmltools::tags$img(\n            src = \"../_static/canvas_submission.png\",\n            alt = \"Submit Assignment Image\",\n            style = \"max-width: 400px; border: 1px solid black; margin-left: 5em;\"\n        ),\n        htmltools::p(\n            \"Either drag the file you saved in the first step or click \",\n            \"\\\"Choose a file to upload\\\" under the rocket drawing \",\n            \"to find the file.\"\n        )\n        ),\n        htmltools::tags$li(\n        \"Finally, click the \\\"Submit Assignment\\\" button.\"\n        )\n    )\n  )\n}\n.progress_submit <- function(assignment_name, n_exercises, progress_obj = .webr_progress) {\n  all <- as.character(1:n_exercises)\n  done <- gsub(\"e\", \"\", sort(unique(progress_obj$label[progress_obj$result])))\n  todo <- setdiff(all, done)\n  collapse_runs <- function(x) {\n    x <- as.integer(x)\n    out <- character()\n    for (i in seq_along(x)) {\n      if (i == 1) {\n        run_start <- run_end <- x[i]\n        next\n      }\n      if (x[i] == run_end + 1) {\n        run_end <- x[i]\n      } else {\n        if (run_start == run_end) {\n          out <- c(out, as.character(run_start))\n        } else {\n          out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n        }\n        run_start <- run_end <- x[i]\n      }\n    }\n    if (run_start == run_end) {\n      out <- c(out, as.character(run_start))\n    } else {\n      out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n    }\n    out\n  }\n  collapse_nums <- function(x) {\n    x <- collapse_runs(x)\n    if (length(x) == 1) {\n      return(x)\n    } else if (length(x) == 2) {\n      return(glue::glue(\"{x[1]} and {x[2]}\"))\n    } else {\n      return(glue::glue_collapse(x, \", \", last = \", and \"))\n    }\n  }\n  if (length(todo) > 0) {\n    htmltools::div(\n      htmltools::tags$p(\n        glue::glue(\n          \"Before you can submit you still need correctly complete exercises \",\n          collapse_nums(todo),\n          \".\"\n          ),\n          style = \"color: red; font-weight: bold;\"\n      ),\n      .save_restore_progress(assignment_name)\n    )\n  } else {\n    htmltools::div(\n      htmltools::p(\n        \"All done! You can submit now!\",\n        style = \"color: green; font-weight: bold;\"\n      ),\n    .steps_to_submit(assignment_name)\n    )\n  }\n}\n```\n:::\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Exposition\n\n### Introduction\n\nIn this exercise we will explore three important atomic data types called\nnumeric, logical, and character. We call them *atomic* because they can\nnot be broken down into simpler data structures.[^notatomic]\n\n[^notatomic]: Much like we now know that atoms can, in fact, be split into smaller\nsubatomic particles, these atomic data types can also be split further, but that\nis far beyond the scope of this course.\n\nContrast this with *complex* data types that we will learn about in\nlater lessons and which are composed by these atomic data types.\n\n### Numeric\n\nYou have already met the numeric data type in [Rithmatic](01-Rithmatic.html).\nHow do you know? We can just ask R if `1`{.r} is numeric by\ntyping and running `is.numeric(1)`{.r}. Try it yourself:\n\n\n::: {.cell caption='Exercise 1' exercise='e1'}\n```{webr}\n#| caption: Exercise 1\n#| exercise: e1\n```\n:::\n\n\n::: { .solution exercise=\"e1\" }\n\n::: {.cell exercise='e1' solution='true'}\n```{webr}\n#| exercise: e1\n#| solution: true\nis.numeric(1)\n```\n:::\n\n:::\n\n\n::: {.cell exercise='e1' check='true'}\n```{webr}\n#| exercise: e1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n`is.numeric`{.r} is a name that refers to a method or recipe in R, called a *function*, that determines if the value it recieves is a number or not, i.e., is it numeric or not.\n\nNow, try running `is.numeric(2 + 2)`{.r} to see the result.\n\n\n::: {.cell caption='Exercise 2' exercise='e2'}\n```{webr}\n#| caption: Exercise 2\n#| exercise: e2\n```\n:::\n\n\n\n::: {.cell exercise='e2' solution='true'}\n```{webr}\n#| exercise: e2\n#| solution: true\nis.numeric(2 + 2)\n```\n:::\n\n\n\n::: {.cell exercise='e2' check='true'}\n```{webr}\n#| exercise: e2\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n### Logical\n\nI hope you've noticed that R responds `TRUE`{.r} when the value the `is.numeric`{.r} function recieves is indeed numeric.\n\nThe value `TRUE`{.r} is a kind of the next atomic data type we will explore, i.e., the logical data type.\n\n`TRUE`{.r} is R's word for \"yes.\" R is case-sensitive, so `TRUE`{.r} is not the same as `true`{.r}, `True`{.r},\nor even `TrUe`{.r}, so be sure to type it carefully.\nR can be very particular about such things.\n\n`TRUE`{.r} is not a numeric value.  How can you find out?\n\n\n::: {.cell caption='Exercise 3' exercise='e3'}\n```{webr}\n#| caption: Exercise 3\n#| exercise: e3\n```\n:::\n\n\n\n::: {.cell exercise='e3' solution='true'}\n```{webr}\n#| exercise: e3\n#| solution: true\nis.numeric(TRUE)\n```\n:::\n\n\n\n::: {.cell exercise='e3' check='true'}\n```{webr}\n#| exercise: e3\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nInstead of `TRUE`{.r}, R responds with `FALSE`{.r}, which is R's word for \"no.\"  `TRUE`{.r} and `FALSE`{.r} are the only two possible values for the logical data type in R.\n\nCan you guess how we test for logical values? Try running `is.logical(FALSE)`{.r}.\n\n\n::: {.cell caption='Exercise 4' exercise='e4'}\n```{webr}\n#| caption: Exercise 4\n#| exercise: e4\n```\n:::\n\n\n\n::: {.cell exercise='e4' solution='true'}\n```{webr}\n#| exercise: e4\n#| solution: true\nis.logical(FALSE)\n```\n:::\n\n\n\n::: {.cell exercise='e4' check='true'}\n```{webr}\n#| exercise: e4\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nIf you ran `is.logical(TRUE)`{.r}, what should the answer be?\nType and check it below.\n\n\n::: {.cell caption='Exercise 5' exercise='e5'}\n```{webr}\n#| caption: Exercise 5\n#| exercise: e5\n```\n:::\n\n\n\n::: {.cell exercise='e5' solution='true'}\n```{webr}\n#| exercise: e5\n#| solution: true\nTRUE\n```\n:::\n\n\n\n::: {.cell exercise='e5' check='true'}\n```{webr}\n#| exercise: e5\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nR will let you use `T`{.r} for `TRUE`{.r} and `F`{.r} for `FALSE`{.r}, but please don't do that in this class or\nin your work.  It makes your code harder to read for others, just as it made it harder for your 5th grade teacher to\ngrade your true-false test. However, I want you to know that in case you see someone use it in their code or if your instructor is being lazy as he types in class. After all,\nthat's only what it should be---a shortcut. Note, though your instructor always types `TRUE`{.r} and `FALSE`{.r} out completely in his production code as 4--5 extra characters are worth the clarity.\n\nOK, I'm pretty confident you have this now. What would `is.logical(1)`{.r} return?\n\n\n::: {.cell caption='Exercise 6' exercise='e6'}\n```{webr}\n#| caption: Exercise 6\n#| exercise: e6\n```\n:::\n\n\n\n::: {.cell exercise='e6' solution='true'}\n```{webr}\n#| exercise: e6\n#| solution: true\nFALSE\n```\n:::\n\n\n\n::: {.cell exercise='e6' check='true'}\n```{webr}\n#| exercise: e6\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n### Character\n\nThe last important atomic data type you should know about\nfor now is the character data type. The character type is used to represent text in R. So you know some of the lingo text for computers is often called *character strings* or simply *strings*.\n\nR knows you intend something to be a string if you enclose it in quotes. The preferred style in R code is to use double quotes,\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"Hello!\"\n```\n:::\n\n\nbut single quotes\n\n\n::: {.cell}\n\n```{.r .cell-code}\n'Hello!'\n```\n:::\n\n\nalso work just fine and are sometimes important for getting\nyour code to work right as we will see.\n\nSee what R does when you type and run `\"Hello, my name is R\"`{.r}.\n\n\n::: {.cell caption='Exercise 7' exercise='e7'}\n```{webr}\n#| caption: Exercise 7\n#| exercise: e7\n```\n:::\n\n\n\n::: {.cell exercise='e7' solution='true'}\n```{webr}\n#| exercise: e7\n#| solution: true\n\"Hello, my name is R\"\n```\n:::\n\n\n\n::: {.cell exercise='e7' check='true'}\n```{webr}\n#| exercise: e7\n#| check: true\ngradethis::grade_this({\n  if (.user_code == '\"Hello, my name is R\"') {\n    pass()\n  } else if (.user_code == \"'Hello, my name is R'\") {\n    pass(glue::glue(\"It works, but remember double quotes are preferred\",\n     \" when writing R code. Note that even R's response uses them!\"\n    ))\n  } else {\n    fail(\"Type it just like I wrote it.\", encourage = TRUE)\n  }\n})\n```\n:::\n\n\nEven though double quotes are preferred, single quotes can be used. Let's\ntest that by typing and running `'What is your name?'`{.r}.\n\n\n::: {.cell caption='Exercise 8' exercise='e8'}\n```{webr}\n#| caption: Exercise 8\n#| exercise: e8\n```\n:::\n\n\n\n::: {.cell exercise='e8' solution='true'}\n```{webr}\n#| exercise: e8\n#| solution: true\n'What is your name?'\n```\n:::\n\n\n\n::: {.cell exercise='e8' check='true'}\n```{webr}\n#| exercise: e8\n#| check: true\ngradethis::grade_this({\n  if (.user_code == \"'What is your name?'\") {\n    pass()\n  } else if (.user_code == '\"What is your name?\"') {\n    pass(glue::glue(\"You are right that double quotes are preferred,\",\n     \" but this time I wanted you to use single quotes.\"\n    ))\n  } else {\n    fail(\"Type it just like I wrote it.\", encourage = TRUE)\n  }\n})\n```\n:::\n\n\n\n::: {.cell exercise='e8' type='open-on-pass'}\n```{adm}\n#| exercise: e8\n#| type: open-on-pass\nLook at R's response above. R said back `\"What is your name?\"` with double\nquotes even when single quotes were used, which emphasizes, in part, why double\nquotes are preferred when writing R code.\n```\n:::\n\n\nSince the `is.logical`{.r} function tests whether something is of the logical\ndatatype, and `is.numeric`{.r} tests whether something is of the numeric data\ntype, what function do you think tests whether something is of the character\ntype?\n\nGo for it!  Test whether\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"Hi!\"\n```\n:::\n\n\nis of type character.\n\n\n::: {.cell caption='Exercise 9' exercise='e9'}\n```{webr}\n#| caption: Exercise 9\n#| exercise: e9\n```\n:::\n\n\n\n::: {.cell exercise='e9' solution='true'}\n```{webr}\n#| exercise: e9\n#| solution: true\nis.character(\"Hi!\")\n```\n:::\n\n\n\n::: {.cell exercise='e9' check='true'}\n```{webr}\n#| exercise: e9\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n## Experimentation\n\nNow it is time to try out your skills. Experiment below and figure out\nwhich atomic data type (numeric, logical, or character) is the result of\ndividing another number by zero.\n\n\n::: {.cell caption='Experiment'}\n```{webr}\n#| caption: Experiment\n```\n:::\n\n\nWhat did you conclude?  Type just `numeric`, `logical`, or `character`\nbelow.\n\n\n::: {.cell caption='Exercise 10' exercise='e10'}\n```{webr}\n#| caption: Exercise 10\n#| exercise: e10\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e10' solution='true'}\n```{webr}\n#| exercise: e10\n#| solution: true\nnumeric\n```\n:::\n\n\n\n::: {.cell exercise='e10' check='true'}\n```{webr}\n#| exercise: e10\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nYou know what `is.character(2)`{.r} will return, right? ... `FALSE`{.r} \n\nBut what if you wanted to use `is.character`{.r} and the number `2`{.r}\ntogether, and get `TRUE`{.r} instead (i.e., what would you need to add \nsurrounding the number `2`{.r} to get `TRUE`{.r})?  \n\nType the full expression using `is.character`{.r} and the\nnumber `2`{.r} that returns `TRUE`{.r}.\n\n\n::: {.cell caption='Exercise 11' exercise='e11'}\n```{webr}\n#| caption: Exercise 11\n#| exercise: e11\n```\n:::\n\n\n\n::: {.cell exercise='e11' solution='true'}\n```{webr}\n#| exercise: e11\n#| solution: true\nis.character(\"2\")\n```\n:::\n\n\n\n::: {.cell exercise='e11' hint='true'}\n```{webr}\n#| exercise: e11\n#| hint: true\nWhat do you enclose a group of characters in to make R recognize it as a \ncharacter type?\n```\n:::\n\n\n\n::: {.cell exercise='e11' check='true'}\n```{webr}\n#| exercise: e11\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n## Exposition, part 2\n\n### Logical Operators\n\nUseful operators for the logical data type include `&`{.r}, `|`{.r}, and `!`{.r}. They are called logical operators. The `|`{.r} is often called a pipe character. \n\n```{=html}\n<div>You usually find the pipe, <code class=\"sourceCode r\"><span class=\"sc\">|</span></code>,\nabove the backslash, <code class=\"sourceCode r\"><span class=\"sc\">\\</span></code>, on a key at the right edge \nof your keyboard, i.e., \n<kbd><div>|</div><div>\\</div></kbd>, which means you need to press \n<span class=\"kbdcombo\">\n  <kbd>Shift</kbd> + <kbd><div>|</div><div>\\</div></kbd>\n  </span> to get the \n<code class=\"sourceCode r\"><span class=\"sc\">|</span></code> character. \n</div><br/>\n```\n\nLet's try each of the logical operators out, starting with the `!`{.r} operator. In the code cell below, try evaluating both `!TRUE`{.r} and `!FALSE`{.r} below, then answer the questions that follow.\n\n\n::: {.cell caption='Experiment'}\n```{webr}\n#| caption: Experiment\n```\n:::\n\n\nWhat does the `!`{.r} operator return when applied to `TRUE`{.r}?\n\n\n::: {.cell caption='Exercise 12' exercise='e12'}\n```{webr}\n#| caption: Exercise 12\n#| exercise: e12\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e12' solution='true'}\n```{webr}\n#| exercise: e12\n#| solution: true\nFALSE\n```\n:::\n\n\n\n::: {.cell exercise='e12' check='true'}\n```{webr}\n#| exercise: e12\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhat does the `!`{.r} operator return when applied to `FALSE`{.r}?\n\n\n::: {.cell caption='Exercise 13' exercise='e13'}\n```{webr}\n#| caption: Exercise 13\n#| exercise: e13\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e13' solution='true'}\n```{webr}\n#| exercise: e13\n#| solution: true\nTRUE\n```\n:::\n\n\n\n::: {.cell exercise='e13' check='true'}\n```{webr}\n#| exercise: e13\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow, experiment with the `&`{.r} and `|`{.r} operators. Try all combinations of `TRUE`{.r} and `FALSE`{.r} (e.g., `TRUE & FALSE`{.r}, `FALSE | FALSE`{.r}, etc.), then answer the questions that follow.\n\n\n::: {.cell caption='Experiment'}\n```{webr}\n#| caption: Experiment\n```\n:::\n\n\nWhat is `TRUE & FALSE`{.r}?\n\n\n::: {.cell caption='Exercise 14' exercise='e14'}\n```{webr}\n#| caption: Exercise 14\n#| exercise: e14\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e14' solution='true'}\n```{webr}\n#| exercise: e14\n#| solution: true\nFALSE\n```\n:::\n\n\n\n::: {.cell exercise='e14' check='true'}\n```{webr}\n#| exercise: e14\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhat is `TRUE | FALSE`{.r}?\n\n\n::: {.cell caption='Exercise 15' exercise='e15'}\n```{webr}\n#| caption: Exercise 15\n#| exercise: e15\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e15' solution='true'}\n```{webr}\n#| exercise: e15\n#| solution: true\nTRUE\n```\n:::\n\n\n\n::: {.cell exercise='e15' check='true'}\n```{webr}\n#| exercise: e15\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhat is `TRUE | TRUE`{.r}?\n\n\n::: {.cell caption='Exercise 16' exercise='e16'}\n```{webr}\n#| caption: Exercise 16\n#| exercise: e16\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e16' solution='true'}\n```{webr}\n#| exercise: e16\n#| solution: true\nTRUE\n```\n:::\n\n\n\n::: {.cell exercise='e16' check='true'}\n```{webr}\n#| exercise: e16\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhich operator name best fits `&`{.r}? Type either\n`\"or\"`, `\"and\"`, or `\"not\"`.  Don't forget the double\nquotes!\n\n\n::: {.cell caption='Exercise 17' exercise='e17'}\n```{webr}\n#| caption: Exercise 17\n#| exercise: e17\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e17' solution='true'}\n```{webr}\n#| exercise: e17\n#| solution: true\n\"and\"\n```\n:::\n\n\n\n::: {.cell exercise='e17' check='true'}\n```{webr}\n#| exercise: e17\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhich operator name best fits `|`{.r}? Type either\n`\"or\"`, `\"and\"`, or `\"not\"`.\n\n\n::: {.cell caption='Exercise 18' exercise='e18'}\n```{webr}\n#| caption: Exercise 18\n#| exercise: e18\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e18' solution='true'}\n```{webr}\n#| exercise: e18\n#| solution: true\n\"or\"\n```\n:::\n\n\n\n::: {.cell exercise='e18' check='true'}\n```{webr}\n#| exercise: e18\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n::: {.cell exercise='e18' type='open-on-pass'}\n```{adm}\n#| exercise: e18\n#| type: open-on-pass\nYou may have been surprised that `TRUE | TRUE`{.r} is `TRUE`{.r} above because \nin English the statement is ambiguous.  We often say things like \"if A is true \nor B is true (or both)\" to make ourselves clear, but in R (and in mathematics\nin general) the \"or\" operator means \"or\" in the inclusive sense, i.e.,\nif either A or B is true *or both are true*, then the result is TRUE.\n```\n:::\n\n\n\n::: {.callout-note}\nThe `!`{.r} operator is different from the others you have seen so far in that it only takes one input (argument), whereas the others take two. One-argument operators are called *unary*, while those that take two are called *binary*. Those that take more than two are called *multiary* or *multary*. So `!`{.r} is unary while `+`{.r}, `&`{.r}, and others you have learned so far are binary. We have not yet met any multiary operators: `2 + 2 + 3`{.r} is just using a binary operator twice.\n:::\n\n## Relational Operators\n\nAnother group of useful binary operators for all the atomic data types are the six relational operators: `<`{.r}, `>`{.r}, `<=`{.r}, `>=`{.r}, `==`{.r}, and `!=`{.r}. Most situations make sense intuitively, especially with numerics, when you know their meaning.\n\nThe symbol `<`{.r} means \"less than\", and `>`{.r} means \"greater than\". So, `5 > 6`{.r} is `FALSE`{.r} and `5 < 6`{.r} is `TRUE`{.r}. The symbol `<=`{.r} means \"less than or equal to\". So, `5 <= 5`{.r} is `TRUE`{.r} as is `5 <= 6`{.r}.\n\nTwo equal signs without any space between them `==`{.r} is the test of whether two things are equal or not. A single equals sign `=`{.r} means something different, so be careful or you will get an error message from your code or worse an unsuspected logical error (a \"bug\") that may surprise you! The symbol `!=`{.r} tests whether two things are not equal.\n\nSo, `3 == 3`{.r} is `TRUE`{.r} and `2 != 3`{.r} is `TRUE`{.r}.\n\nLet's test your knowledge. What is `5 == 10`{.r}?\n\n\n::: {.cell caption='Exercise 19' exercise='e19'}\n```{webr}\n#| caption: Exercise 19\n#| exercise: e19\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e19' solution='true'}\n```{webr}\n#| exercise: e19\n#| solution: true\nFALSE\n```\n:::\n\n\n\n::: {.cell exercise='e19' check='true'}\n```{webr}\n#| exercise: e19\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhat is `8 > 10`{.r}?\n\n\n::: {.cell caption='Exercise 20' exercise='e20'}\n```{webr}\n#| caption: Exercise 20\n#| exercise: e20\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e20' solution='true'}\n```{webr}\n#| exercise: e20\n#| solution: true\nFALSE\n```\n:::\n\n\n\n::: {.cell exercise='e20' check='true'}\n```{webr}\n#| exercise: e20\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhat is `100 < 101`{.r}?\n\n\n::: {.cell caption='Exercise 21' exercise='e21'}\n```{webr}\n#| caption: Exercise 21\n#| exercise: e21\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e21' solution='true'}\n```{webr}\n#| exercise: e21\n#| solution: true\nTRUE\n```\n:::\n\n\n\n::: {.cell exercise='e21' check='true'}\n```{webr}\n#| exercise: e21\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhat is `\"a\" < \"b\"`{.r}? (Trust your gut on this one!)\n\n\n::: {.cell caption='Exercise 22' exercise='e22'}\n```{webr}\n#| caption: Exercise 22\n#| exercise: e22\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e22' solution='true'}\n```{webr}\n#| exercise: e22\n#| solution: true\nTRUE\n```\n:::\n\n\n\n::: {.cell exercise='e22' check='true'}\n```{webr}\n#| exercise: e22\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nSo, that probably made sense but does the fact that `\"B\"`{.r} is less than \n`\"a\"`{.r} make sense?  Perhaps not, but the capitals are all less than the\nlower case letters and most (if not all) punctuation is less than upper case\nletters and thus the lower case letters too.\n\nWhat is `\"b\" > \"!\"`{.r}?\n\n\n::: {.cell caption='Exercise 23' exercise='e23'}\n```{webr}\n#| caption: Exercise 23\n#| exercise: e23\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e23' solution='true'}\n```{webr}\n#| exercise: e23\n#| solution: true\nTRUE\n```\n:::\n\n\n\n::: {.cell exercise='e23' check='true'}\n```{webr}\n#| exercise: e23\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhat is `\"A\" == \"a\"`{.r}?\n\n\n::: {.cell caption='Exercise 24' exercise='e24'}\n```{webr}\n#| caption: Exercise 24\n#| exercise: e24\n#| output: false\n```\n:::\n\n\n\n::: {.cell exercise='e24' solution='true'}\n```{webr}\n#| exercise: e24\n#| solution: true\nFALSE\n```\n:::\n\n\n\n::: {.cell exercise='e24' check='true'}\n```{webr}\n#| exercise: e24\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhat is `TRUE > FALSE`{.r}? \n\n\n::: {.cell caption='Exercise 25' exercise='e25'}\n```{webr}\n#| caption: Exercise 25\n#| exercise: e25\n```\n:::\n\n\n::: { .solution exercise=\"e25\" }\n\n::: {.cell exercise='e25' solution='true'}\n```{webr}\n#| exercise: e25\n#| solution: true\n```\n:::\n\n\n`TRUE` is the answer! After all, truth is indeed greater than falsity! Now you have a good sense of how the relational operators work on all the data types we've learned about.\n:::\n\n\n::: {.cell exercise='e25' check='true'}\n```{webr}\n#| exercise: e25\n#| check: true\ngradethis::grade_this({\n  if (.user_code == \"TRUE\") {\n    pass(\"Correct!\")\n  } else {\n    fail(\"Nope... try the other one. ☺️\")\n  }\n})\n```\n:::\n\n\n\n::: {.cell exercise='e25' type='open-solution-on-pass'}\n```{adm}\n#| exercise: e25\n#| type: open-solution-on-pass\n```\n:::\n\n\n## Evaluation\n\n### Submit Your Assignment\n\n\n::: {.cell type='progress-submit'}\n```{adm}\n#| type: progress-submit\n```\n:::\n\n::: {#adm-progress-submit}\n\n::: {.cell autorun='true'}\n```{webr}\n#| autorun: true\n.progress_submit(\"02-Atomic-Data-Types\", 25)\n```\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}