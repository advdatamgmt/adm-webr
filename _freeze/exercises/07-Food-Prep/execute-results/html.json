{
  "hash": "a984ba7cab9f1a1cd702404319f6013c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Food Prep\"\norder: 700\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\n###########################################################\n# if you edit this section note there is an `r` block below too\n.course_id <- readLines(\"_static/data/course_id.txt\")\n.assignment_ids <- dget(\"_static/data/assignment_ids.txt\")\n.canvas_link <- function(a) glue::glue(\"https://canvas.emory.edu/courses/{.course_id}/assignments/{.assignment_ids[{a}]}\")\n############################################################\n.webr_progress <- data.frame(label = character(), user_code = character(), solution_code = character(), result = logical())\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    res <- gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n    .webr_progress <<- rbind(\n      .webr_progress,\n      data.frame(\n        label = label,\n        user_code = user_code,\n        solution_code = solution_code,\n        result = res$correct\n      )\n    )\n    res\n  }\n})\n.csv_data_uri <- function(df) {\n  enc_csv <- base64enc::base64encode(\n    charToRaw(\n      paste(\n        capture.output(\n          write.csv(df)),\n          collapse = \"\\n\")\n    )\n  )\n  glue::glue(\"data:text/csv;base64,{enc_csv}\")\n}\n.save_restore_progress <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::tags$a(\n      download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n      href = .csv_data_uri(df),\n      htmltools::tags$button(\n          #onClick = \"this.classList.add('clicked');\",\n          class = \"btn progress-submit\",\n          \"Save progress\",\n          .noWS = \"outside\"\n      )\n    ),\n    htmltools::tags$label(\n      `for` = \"restore-file-input\",\n      type = \"button\",\n      id = \"restore-progress-button\",\n      class = \"btn progress-submit btn-quarto\",\n      onClick = \"restore_listener();\",\n      \"Restore progress\"\n    ),\n    htmltools::tags$input(\n      type = \"file\",\n      id = \"restore-file-input\",\n      style = \"display: none\",\n      accept = \".csv\"\n    )\n  )\n}\n.steps_to_submit <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::p(\n      htmltools::strong(\"Steps to submit:\")\n    ),\n    htmltools::tags$ol(\n        htmltools::tags$li(\n        \"Save your work to your device by clicking: \",\n        htmltools::tags$a(\n            download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n            href = .csv_data_uri(df),\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Download\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"Go to related Canvas assignment (note this will open a new tab or window and you may need to login) by clicking:\",\n        htmltools::tags$a(\n            href = .canvas_link(assignment_name),\n            target = \"_blank\",\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Open Canvas Assignment\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"On the page that just opened find and click on a button\",\n        \"that looks like this in the upper right corner:\",\n        htmltools::tags$img(\n            src = \"../_static/canvas_start_assignment.png\",\n            alt = \"Start Assignment Button\",\n            style = \"max-width: 200px; border: 1px solid black; margin-left: 1em;\"\n        )\n        ),\n        htmltools::tags$li(\n        htmltools::p(\"After you click you should see the following:\"),\n        htmltools::tags$img(\n            src = \"../_static/canvas_submission.png\",\n            alt = \"Submit Assignment Image\",\n            style = \"max-width: 400px; border: 1px solid black; margin-left: 5em;\"\n        ),\n        htmltools::p(\n            \"Either drag the file you saved in the first step or click \",\n            \"\\\"Choose a file to upload\\\" under the rocket drawing \",\n            \"to find the file.\"\n        )\n        ),\n        htmltools::tags$li(\n        \"Finally, click the \\\"Submit Assignment\\\" button.\"\n        )\n    )\n  )\n}\n.progress_submit <- function(assignment_name, n_exercises, progress_obj = .webr_progress) {\n  all <- as.character(1:n_exercises)\n  done <- gsub(\"e\", \"\", sort(unique(progress_obj$label[progress_obj$result])))\n  todo <- setdiff(all, done)\n  collapse_runs <- function(x) {\n    x <- as.integer(x)\n    out <- character()\n    for (i in seq_along(x)) {\n      if (i == 1) {\n        run_start <- run_end <- x[i]\n        next\n      }\n      if (x[i] == run_end + 1) {\n        run_end <- x[i]\n      } else {\n        if (run_start == run_end) {\n          out <- c(out, as.character(run_start))\n        } else {\n          out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n        }\n        run_start <- run_end <- x[i]\n      }\n    }\n    if (run_start == run_end) {\n      out <- c(out, as.character(run_start))\n    } else {\n      out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n    }\n    out\n  }\n  collapse_nums <- function(x) {\n    x <- collapse_runs(x)\n    if (length(x) == 1) {\n      return(x)\n    } else if (length(x) == 2) {\n      return(glue::glue(\"{x[1]} and {x[2]}\"))\n    } else {\n      return(glue::glue_collapse(x, \", \", last = \", and \"))\n    }\n  }\n  if (length(todo) > 0) {\n    htmltools::div(\n      htmltools::tags$p(\n        glue::glue(\n          \"Before you can submit you still need correctly complete exercises \",\n          collapse_nums(todo),\n          \".\"\n          ),\n          style = \"color: red; font-weight: bold;\"\n      ),\n      .save_restore_progress(assignment_name)\n    )\n  } else {\n    htmltools::div(\n      htmltools::p(\n        \"All done! You can submit now!\",\n        style = \"color: green; font-weight: bold;\"\n      ),\n    .steps_to_submit(assignment_name)\n    )\n  }\n}\n```\n:::\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Exposition\n\n### Introduction\n\nThis module focuses on several common data manipulation tasks: selecting, subsetting, concatenating, merging, and sorting. Some you have already seen before, but now is a good time for review and reinforcement. For example, recall that when you want to select a part of a vector, you use square brackets, `[]`{.r}, placing between them a numeric vector that lists the elements you want to extract.\n\nLet's get started!\n\n### Subsetting and combining vectors\n\nR has a built-in vector that contains the capital letters: `LETTERS`{.r}. Let’s try a few things with that vector. First just type, `LETTERS`{.r} to see what is inside.\n\n\n::: {.cell caption='Exercise 1' exercise='e1'}\n```{webr}\n#| caption: Exercise 1\n#| exercise: e1\n```\n:::\n\n\n::: {.solution exercise=\"e1\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e1' solution='true'}\n```{webr}\n#| exercise: e1\n#| solution: true\nLETTERS\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e1' check='true'}\n```{webr}\n#| exercise: e1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nSo, how would you get the 10th letter from `LETTERS`{.r}?\n\n\n::: {.cell caption='Exercise 2' exercise='e2'}\n```{webr}\n#| caption: Exercise 2\n#| exercise: e2\n```\n:::\n\n\n::: {.solution exercise=\"e2\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e2' solution='true'}\n```{webr}\n#| exercise: e2\n#| solution: true\nLETTERS[10]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e2' check='true'}\n```{webr}\n#| exercise: e2\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nHow about selecting the 15th through the 22nd letters? Don't forget about the `:`{.r} operator!\n\n\n::: {.cell caption='Exercise 3' exercise='e3'}\n```{webr}\n#| caption: Exercise 3\n#| exercise: e3\n```\n:::\n\n\n::: {.hint exercise=\"e3\"}\n::: {.callout-note collapse=\"false\"}\n15:22 is a part of the answer\n:::\n:::\n\n::: {.solution exercise=\"e3\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e3' solution='true'}\n```{webr}\n#| exercise: e3\n#| solution: true\nLETTERS[15:22]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e3' check='true'}\n```{webr}\n#| exercise: e3\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nIf I wanted the odd letters, I could do this:\n\n`LETTERS[c(1,3,5,7,9,11,13,15,17,19,21,23,25)]`{.r}\n\nBut that's a lot of work. Anytime you see something like this in your code you should try to figure out a way to do it more automatically. There is a function called `seq`{.r} that creates sequences of numbers.\n\nType:\n\n`seq(1, 26, by = 2)`{.r}\n\nto see what it does.\n\n\n::: {.cell caption='Exercise 4' exercise='e4'}\n```{webr}\n#| caption: Exercise 4\n#| exercise: e4\n```\n:::\n\n\n::: {.solution exercise=\"e4\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e4' solution='true'}\n```{webr}\n#| exercise: e4\n#| solution: true\nseq(1, 26, by = 2)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e4' check='true'}\n```{webr}\n#| exercise: e4\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nBefore proceeding, take a look at the help for `seq`{.r} since it is a very\nuseful function.\n\n\n::: {.cell edit='false' autorun='true'}\n```{webr}\n#| edit: false\n#| autorun: true\n?seq\n```\n:::\n\n\nNow use `seq` to get the odd letters from `LETTERS`{.r}.\n\n\n::: {.cell caption='Exercise 5' exercise='e5'}\n```{webr}\n#| caption: Exercise 5\n#| exercise: e5\n```\n:::\n\n\n::: {.hint exercise=\"e5\"}\n::: {.callout-note collapse=\"false\"}\nDoes LETTERS[seq(...)] as a suggestion help?\n:::\n:::\n\n::: {.solution exercise=\"e5\"}\n::: {.callout-note collapse=\"false\"}\nAny of the following will work:\n\n::: {.cell exercise='e5' solution='true'}\n```{webr}\n#| exercise: e5\n#| solution: true\nLETTERS[seq(1, length.out = 13, by = 2)]\nLETTERS[seq(to = 25, by = 2)]\nLETTERS[seq(to = 26, by = 2)]\nLETTERS[seq(1, 25, by = 2)]\nLETTERS[seq(1, 26, by = 2)]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e5' check='true'}\n```{webr}\n#| exercise: e5\n#| check: true\ngradethis::grade_this({\n  # pass if the value is correct\n  pass_if_equal()\n\n  # or fallback to a failing grade\n  fail(hint = TRUE)\n})\n```\n:::\n\n\nNow get the even letters from `LETTERS`{.r} also using `seq`{.r}.\n\n\n::: {.cell caption='Exercise 6' exercise='e6'}\n```{webr}\n#| caption: Exercise 6\n#| exercise: e6\n```\n:::\n\n\n::: {.hint exercise=\"e6\"}\n::: {.callout-note collapse=\"false\"}\nWith what number should you start?\n:::\n:::\n\n::: {.solution exercise=\"e6\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e6' solution='true'}\n```{webr}\n#| exercise: e6\n#| solution: true\nLETTERS[seq(2, length.out = 13)]\nLETTERS[seq(2, 26, by = 2)]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e6' check='true'}\n```{webr}\n#| exercise: e6\n#| check: true\ngradethis::grade_this({\n  # pass if the value is correct\n  pass_if_equal()\n\n  # or fallback to a failing grade\n  fail(hint = TRUE)\n})\n```\n:::\n\n\nAnother good function named `rep`{.r}, which is technically a mnemonic for \"replicate\" but I typically remember it as \"repeat\". Try `rep(5, 10)`{.r}.\n\n\n::: {.cell caption='Exercise 7' exercise='e7'}\n```{webr}\n#| caption: Exercise 7\n#| exercise: e7\n```\n:::\n\n\n::: {.solution exercise=\"e7\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e7' solution='true'}\n```{webr}\n#| exercise: e7\n#| solution: true\nrep(5, 10)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e7' check='true'}\n```{webr}\n#| exercise: e7\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nAgain, such a useful function that you should take a look at the help for it.\n\n\n::: {.cell edit='false' autorun='true'}\n```{webr}\n#| edit: false\n#| autorun: true\n?rep\n```\n:::\n\n\nNow that you've looked through the help, let's see more of the flexibility of `rep`{.r}. Here are some examples.  Based on what you read in the help, see if you can figure out what each one will do before you run it.  If any do not make sense, make a note to ask about it in class.\n\n`rep(c(1, 2), 5)`{.r}\n\n\n::: {.cell caption='Exercise 8' exercise='e8'}\n```{webr}\n#| caption: Exercise 8\n#| exercise: e8\n```\n:::\n\n\n::: {.solution exercise=\"e8\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e8' solution='true'}\n```{webr}\n#| exercise: e8\n#| solution: true\nrep(c(1, 2), 5)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e8' check='true'}\n```{webr}\n#| exercise: e8\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNext try:\n\n`rep(c(1, 2), each = 5)`{.r}\n\n\n::: {.cell caption='Exercise 9' exercise='e9'}\n```{webr}\n#| caption: Exercise 9\n#| exercise: e9\n```\n:::\n\n\n::: {.solution exercise=\"e9\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e9' solution='true'}\n```{webr}\n#| exercise: e9\n#| solution: true\nrep(c(1, 2), each = 5)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e9' check='true'}\n```{webr}\n#| exercise: e9\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNext try:\n\n`rep(1:3, 3:1)`{.r}\n\n\n::: {.cell caption='Exercise 10' exercise='e10'}\n```{webr}\n#| caption: Exercise 10\n#| exercise: e10\n```\n:::\n\n\n::: {.solution exercise=\"e10\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e10' solution='true'}\n```{webr}\n#| exercise: e10\n#| solution: true\nrep(1:3, 3:1)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e10' check='true'}\n```{webr}\n#| exercise: e10\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nAnd there is nothing to stop you from getting the same element of a vector more than once - try:\n\n`LETTERS[rep(1:3, 3:1)]`{.r}\n\n\n::: {.cell caption='Exercise 11' exercise='e11'}\n```{webr}\n#| caption: Exercise 11\n#| exercise: e11\n```\n:::\n\n\n::: {.solution exercise=\"e11\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e11' solution='true'}\n```{webr}\n#| exercise: e11\n#| solution: true\nLETTERS[rep(1:3, 3:1)]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e11' check='true'}\n```{webr}\n#| exercise: e11\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWant to get rid of something? Use negative numbers:\n\n`LETTERS[-26:-21]`{.r}\n\n\n::: {.cell caption='Exercise 12' exercise='e12'}\n```{webr}\n#| caption: Exercise 12\n#| exercise: e12\n```\n:::\n\n\n::: {.solution exercise=\"e12\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e12' solution='true'}\n```{webr}\n#| exercise: e12\n#| solution: true\nLETTERS[-26:-21]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e12' check='true'}\n```{webr}\n#| exercise: e12\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nSo this is another way to get the even numbers!\n\n`LETTERS[-seq(1, 26, by = 2)]`{.r}\n\n\n::: {.cell caption='Exercise 13' exercise='e13'}\n```{webr}\n#| caption: Exercise 13\n#| exercise: e13\n```\n:::\n\n\n::: {.solution exercise=\"e13\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e13' solution='true'}\n```{webr}\n#| exercise: e13\n#| solution: true\nLETTERS[-seq(1, 26, by = 2)]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e13' check='true'}\n```{webr}\n#| exercise: e13\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nRemember that R returns the values where they are `TRUE`{.r} when you use a logical vector to subset a vector.\n\nIf I've created a vector `n5`{.r} that contains the numbers 1 through 5 like this:\n\n\n::: {.cell edit='false' autorun='true'}\n```{webr}\n#| edit: false\n#| autorun: true\nn5 <- 1:5\n```\n:::\n\n\nThink about what you will get if you type:\n\n`n5[c(TRUE, FALSE, TRUE, TRUE, FALSE)]`{.r}\n\nAnd then try it to see if you get the result you expected.\n\n\n::: {.cell caption='Exercise 14' exercise='e14'}\n```{webr}\n#| caption: Exercise 14\n#| exercise: e14\n```\n:::\n\n\n::: {.solution exercise=\"e14\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e14' solution='true'}\n```{webr}\n#| exercise: e14\n#| solution: true\nn5[c(TRUE, FALSE, TRUE, TRUE, FALSE)]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e14' check='true'}\n```{webr}\n#| exercise: e14\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nBecause R \"recycles\" a vector used for subsetting until the length is the same as the longer vector (remember that from our early lessons?) you can get the even letters this way!\n\n`LETTERS[c(FALSE, TRUE)]`{.r}\n\n\n::: {.cell caption='Exercise 15' exercise='e15'}\n```{webr}\n#| caption: Exercise 15\n#| exercise: e15\n```\n:::\n\n\n::: {.solution exercise=\"e15\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e15' solution='true'}\n```{webr}\n#| exercise: e15\n#| solution: true\nLETTERS[c(FALSE, TRUE)]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e15' check='true'}\n```{webr}\n#| exercise: e15\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow use the same technique for the odd letters! How?\n\n\n::: {.cell caption='Exercise 16' exercise='e16'}\n```{webr}\n#| caption: Exercise 16\n#| exercise: e16\n```\n:::\n\n\n::: {.solution exercise=\"e16\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e16' solution='true'}\n```{webr}\n#| exercise: e16\n#| solution: true\nLETTERS[c(TRUE, FALSE)]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e16' check='true'}\n```{webr}\n#| exercise: e16\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nThe vector `letsamp` contains a vector of 100 random letters. Type `letsamp`{.r} to take a look at it.\n\n\n::: {.cell setup='true' exercise='[\"e17\",\"e18\",\"e19\",\"e20\",\"e21\"]'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e17\n#|   - e18\n#|   - e19\n#|   - e20\n#|   - e21\nset.seed(42)\nletsamp <- sample(LETTERS, 100, replace = TRUE)\n```\n:::\n\n\n\n::: {.cell caption='Exercise 17' exercise='e17'}\n```{webr}\n#| caption: Exercise 17\n#| exercise: e17\n```\n:::\n\n\n::: {.solution exercise=\"e17\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e17' solution='true'}\n```{webr}\n#| exercise: e17\n#| solution: true\nletsamp\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e17' check='true'}\n```{webr}\n#| exercise: e17\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nUse `==`{.r} to test which letters are P.\n\n\n::: {.cell caption='Exercise 18' exercise='e18'}\n```{webr}\n#| caption: Exercise 18\n#| exercise: e18\n```\n:::\n\n\n::: {.hint exercise=\"e18\"}\n::: {.callout-note collapse=\"false\"}\nDid you remember the quotes around \"P\"?\n:::\n:::\n\n::: {.solution exercise=\"e18\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e18' solution='true'}\n```{webr}\n#| exercise: e18\n#| solution: true\nletsamp == \"P\"\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e18' check='true'}\n```{webr}\n#| exercise: e18\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nBecause R treats `TRUE`{.r} as equal to `1`{.r} when a logical vector is converted to a numeric vector you can use the `sum`{.r} function to count the P's like this:\n\n`sum(letsamp == \"P\")`{.r}\n\n\n::: {.cell caption='Exercise 19' exercise='e19'}\n```{webr}\n#| caption: Exercise 19\n#| exercise: e19\n```\n:::\n\n\n::: {.solution exercise=\"e19\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e19' solution='true'}\n```{webr}\n#| exercise: e19\n#| solution: true\nsum(letsamp == \"P\")\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e19' check='true'}\n```{webr}\n#| exercise: e19\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nA very useful operator is the `%in%`{.r} operator, which tests if something is \"in\" the vector, and which we saw in the [last module](06-Branch-Loop.qmd).\n\nUse it to \"mind your Ps and Qs\" like this:\n\n`letsamp[letsamp %in% c(\"P\", \"Q\")]`{.r}\n\n\n::: {.cell caption='Exercise 20' exercise='e20'}\n```{webr}\n#| caption: Exercise 20\n#| exercise: e20\n```\n:::\n\n\n::: {.solution exercise=\"e20\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e20' solution='true'}\n```{webr}\n#| exercise: e20\n#| solution: true\nletsamp[letsamp %in% c(\"P\", \"Q\")]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e20' check='true'}\n```{webr}\n#| exercise: e20\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nFinally, don't forget that you can use `c`{.r} to concatenate multiple vectors together in very flexible ways. Try:\n\n`c(LETTERS[1:3], c(\"H\", \"I\"), letsamp[letsamp %in% c(\"P\", \"Q\")])`{.r}\n\n\n::: {.cell caption='Exercise 21' exercise='e21'}\n```{webr}\n#| caption: Exercise 21\n#| exercise: e21\n```\n:::\n\n\n::: {.solution exercise=\"e21\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e21' solution='true'}\n```{webr}\n#| exercise: e21\n#| solution: true\nc(LETTERS[1:3], c(\"H\", \"I\"), letsamp[letsamp %in% c(\"P\", \"Q\")])\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e21' check='true'}\n```{webr}\n#| exercise: e21\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n### Subsetting and merging data frames\n\nOk, let's turn to the doing the same sort of tasks with `data.frame`{.r} as with did with various `vector`{.r} types.  I've pre-loaded a few `data.frame`{.r}'s for you. The first is called `cholera_merge`{.r}. Let's look at its first 6 rows:\n\n\n::: {.cell setup='true' exercise='[\"e22\",\"e23\",\"e24\",\"e25\"]'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e22\n#|   - e23\n#|   - e24\n#|   - e25\nload(\"_static/data/cholera_merge.rda\")\n```\n:::\n\n\n`cholera_merge[1:6, ]`{.r}\n\n\n::: {.cell caption='Exercise 22' exercise='e22'}\n```{webr}\n#| caption: Exercise 22\n#| exercise: e22\n```\n:::\n\n\n::: {.solution exercise=\"e22\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e22' solution='true'}\n```{webr}\n#| exercise: e22\n#| solution: true\ncholera_merge[1:6, ]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e22' check='true'}\n```{webr}\n#| exercise: e22\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nUse a logical operator to get certain rows:\n\n`cholera_merge[cholera_merge$area == 4, ]`{.r}\n\n\n::: {.cell caption='Exercise 23' exercise='e23'}\n```{webr}\n#| caption: Exercise 23\n#| exercise: e23\n```\n:::\n\n\n::: {.solution exercise=\"e23\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e23' solution='true'}\n```{webr}\n#| exercise: e23\n#| solution: true\ncholera_merge[cholera_merge$area == 4, ]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e23' check='true'}\n```{webr}\n#| exercise: e23\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nYou can use `subset`{.r} to seemingly do the same thing:\n\n`subset(cholera_merge, area == 4)`{.r}\n\n\n::: {.cell caption='Exercise 24' exercise='e24'}\n```{webr}\n#| caption: Exercise 24\n#| exercise: e24\n```\n:::\n\n\n::: {.solution exercise=\"e24\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e24' solution='true'}\n```{webr}\n#| exercise: e24\n#| solution: true\nsubset(cholera_merge, area == 4)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e24' check='true'}\n```{webr}\n#| exercise: e24\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::: {#e25}\nHowever, you will run into a problem if you try to do something like:\n\n`subset(cholera_merge, area == 4)$area <- 6`{.r}\n\nIt won't work. So don't type it. Instead, you have to do this:\n\n`cholera_merge[cholera_merge$area == 4, ]$area <- 6`{.r}\n\n\n::: {.cell caption='Exercise 25' exercise='e25'}\n```{webr}\n#| caption: Exercise 25\n#| exercise: e25\n```\n:::\n\n:::\n\n::: {.solution exercise=\"e25\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e25' solution='true'}\n```{webr}\n#| exercise: e25\n#| solution: true\ncholera_merge[cholera_merge$area == 4, ]$area <- 6\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e25' check='true'}\n```{webr}\n#| exercise: e25\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n::: {.cell setup='true' exercise='[\"e26\",\"e27\",\"e28\"]'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e26\n#|   - e27\n#|   - e28\nload(\"_static/data/cholera_merge.rda\")\ncholera_merge[cholera_merge$area == 4, ]$area <- 6\n```\n:::\n\n\nVerify that all the area 4 are now area 6...\n\n`subset(cholera_merge, area == 4)`{.r}\n\n\n::: {.cell caption='Exercise 26' exercise='e26'}\n```{webr}\n#| caption: Exercise 26\n#| exercise: e26\n```\n:::\n\n\n::: {.solution exercise=\"e26\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e26' solution='true'}\n```{webr}\n#| exercise: e26\n#| solution: true\nsubset(cholera_merge, area == 4)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e26' check='true'}\n```{webr}\n#| exercise: e26\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n... and ...\n\n`subset(cholera_merge, area == 6)`{.r}\n\n\n::: {.cell caption='Exercise 27' exercise='e27'}\n```{webr}\n#| caption: Exercise 27\n#| exercise: e27\n```\n:::\n\n\n::: {.solution exercise=\"e27\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e27' solution='true'}\n```{webr}\n#| exercise: e27\n#| solution: true\nsubset(cholera_merge, area == 6)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e27' check='true'}\n```{webr}\n#| exercise: e27\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nAppears it worked. Now it is your turn to put `cholera_merge`{.r} back the way it was using the pattern of test and assignment I showed you [above](#e25).\n\n\n::: {.cell caption='Exercise 28' exercise='e28'}\n```{webr}\n#| caption: Exercise 28\n#| exercise: e28\n```\n:::\n\n\n::: {.solution exercise=\"e28\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e28' solution='true'}\n```{webr}\n#| exercise: e28\n#| solution: true\ncholera_merge[cholera_merge$area == 6, ]$area <- 4\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e28' check='true'}\n```{webr}\n#| exercise: e28\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nYou can combine multiple conditions using `&`{.r} and `|`{.r}, for example, try:\n\n`cholera_merge[cholera_merge$sex == \"F\" & cholera_merge$area == 3, ]`{.r}\n\n\n::: {.cell setup='true' exercise='[\"e29\",\"e30\",\"e31\",\"e32\"]'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e29\n#|   - e30\n#|   - e31\n#|   - e32\nload(\"_static/data/cholera_merge.rda\")\n```\n:::\n\n\n\n::: {.cell caption='Exercise 29' exercise='e29'}\n```{webr}\n#| caption: Exercise 29\n#| exercise: e29\n```\n:::\n\n\n::: {.solution exercise=\"e29\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e29' solution='true'}\n```{webr}\n#| exercise: e29\n#| solution: true\ncholera_merge[cholera_merge$sex == \"F\" & cholera_merge$area == 3, ]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e29' check='true'}\n```{webr}\n#| exercise: e29\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nColumns work the same as rows (I used both together to keep the output short). Try:\n\n`cholera_merge[1:3, 3:4]`{.r}\n\n\n::: {.cell caption='Exercise 30' exercise='e30'}\n```{webr}\n#| caption: Exercise 30\n#| exercise: e30\n```\n:::\n\n\n::: {.solution exercise=\"e30\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e30' solution='true'}\n```{webr}\n#| exercise: e30\n#| solution: true\ncholera_merge[1:3, 3:4]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e30' check='true'}\n```{webr}\n#| exercise: e30\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nAnother example:\n\n`cholera_merge[1:3, c(\"age\", \"sex\")]`{.r}\n\n\n::: {.cell caption='Exercise 31' exercise='e31'}\n```{webr}\n#| caption: Exercise 31\n#| exercise: e31\n```\n:::\n\n\n::: {.solution exercise=\"e31\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e31' solution='true'}\n```{webr}\n#| exercise: e31\n#| solution: true\ncholera_merge[1:3, c(\"age\", \"sex\")]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e31' check='true'}\n```{webr}\n#| exercise: e31\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nAnd another:\n\n`cholera_merge[cholera_merge$area == 4, c(\"age\", \"sex\")]`{.r}\n\n\n::: {.cell caption='Exercise 32' exercise='e32'}\n```{webr}\n#| caption: Exercise 32\n#| exercise: e32\n```\n:::\n\n\n::: {.solution exercise=\"e32\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e32' solution='true'}\n```{webr}\n#| exercise: e32\n#| solution: true\ncholera_merge[cholera_merge$area == 4, c(\"age\", \"sex\")]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e32' check='true'}\n```{webr}\n#| exercise: e32\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nThe function `paste0`{.r} pastes together character vectors without any space between them. It'll come in handy in a moment. Try it:\n\n`paste0(\"a\", \"b\", \"c\")`{.r}\n\n\n::: {.cell caption='Exercise 33' exercise='e33'}\n```{webr}\n#| caption: Exercise 33\n#| exercise: e33\n```\n:::\n\n\n::: {.hint exercise=\"e33\"}\n::: {.callout-note collapse=\"false\"}\nIt is `0`{.r} (zero) not `O`{.r} (oh)\n:::\n:::\n\n::: {.solution exercise=\"e33\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e33' solution='true'}\n```{webr}\n#| exercise: e33\n#| solution: true\npaste0(\"a\", \"b\", \"c\")\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e33' check='true'}\n```{webr}\n#| exercise: e33\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWorks with vectors as one of the arguments also. Try:\n\n`paste0(\"cholera\", 1:5)`{.r}\n\n\n::: {.cell caption='Exercise 34' exercise='e34'}\n```{webr}\n#| caption: Exercise 34\n#| exercise: e34\n```\n:::\n\n\n::: {.solution exercise=\"e34\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e34' solution='true'}\n```{webr}\n#| exercise: e34\n#| solution: true\npaste0(\"cholera\", 1:5)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e34' check='true'}\n```{webr}\n#| exercise: e34\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nAnother useful function is `assign`{.r} that has the same effect as `<-`{.r} but works as a function with a character vector. It allows us to programmatically specify the name using a character vector which is very helpful. Try:\n\n`assign(\"x\", 1:3)`{.r}\n\n\n::: {.cell caption='Exercise 35' exercise='e35' envir='env1'}\n```{webr}\n#| caption: Exercise 35\n#| exercise: e35\n#| envir: env1\n```\n:::\n\n\n::: {.solution exercise=\"e35\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e35' solution='true'}\n```{webr}\n#| exercise: e35\n#| solution: true\nassign(\"x\", 1:3)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e35' check='true'}\n```{webr}\n#| exercise: e35\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nCheck that `x`{.r} is what you think it should be.\n\n\n::: {.cell caption='Exercise 36' exercise='e36' envir='env1'}\n```{webr}\n#| caption: Exercise 36\n#| exercise: e36\n#| envir: env1\n```\n:::\n\n\n::: {.solution exercise=\"e36\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e36' solution='true'}\n```{webr}\n#| exercise: e36\n#| solution: true\nx\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e36' check='true'}\n```{webr}\n#| exercise: e36\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nLet’s divide up `cholera_merge`{.r} into smaller datasets by area. With `assign`{.r} and `paste0`{.r} and the subset methods we've been studying. We can do it with a loop like the following. Study it carefully, make sure you understand it, and then run it.\n\n\n::: {.cell setup='true' exercise='e37'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e37\nload(\"_static/data/cholera_merge.rda\")\n```\n:::\n\n\n\n::: {.cell caption='Exercise 37' exercise='e37'}\n```{webr}\n#| caption: Exercise 37\n#| exercise: e37\nfor(i in 1:5) {\n  assign(paste0(\"cholera\", i), cholera_merge[cholera_merge$area == i, ])\n}\n```\n:::\n\n\n::: {.solution exercise=\"e37\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e37' solution='true'}\n```{webr}\n#| exercise: e37\n#| solution: true\nfor(i in 1:5) {\n  assign(paste0(\"cholera\", i), cholera_merge[cholera_merge$area == i, ])\n}\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e37' check='true'}\n```{webr}\n#| exercise: e37\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow there are five datasets named `cholera1`{.r}, `cholera2`{.r}, $\\dots$, `cholera5`{.r} each containing one area's data.\n\nSee if `cholera1`{.r} is what you think it should be.\n\n\n::: {.cell setup='true' exercise='[\"e38\",\"e39\"]'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e38\n#|   - e39\nload(\"_static/data/cholera_merge.rda\")\nfor(i in 1:5) {\n  assign(paste0(\"cholera\", i), cholera_merge[cholera_merge$area == i, ])\n}\n```\n:::\n\n\n\n::: {.cell caption='Exercise 38' exercise='e38'}\n```{webr}\n#| caption: Exercise 38\n#| exercise: e38\n```\n:::\n\n\n::: {.solution exercise=\"e38\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e38' solution='true'}\n```{webr}\n#| exercise: e38\n#| solution: true\ncholera1\n```\n:::\n\n:::\n::: \n\n\n::: {.cell exercise='e38' check='true'}\n```{webr}\n#| exercise: e38\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nYou can use the function\n`rbind`{.r} to put these five datasets back together as `c_m`{.r}\nlike this:[^better]\n\n`c_m <- rbind(cholera1, cholera2, cholera3, cholera4, cholera5)`{.r}\n\n[^better]: A better way to do this exists if you have lots of datasets, but it is\n  tricky to understand at first and we should wait until later to try it.\n\n\n::: {.cell caption='Exercise 39' exercise='e39'}\n```{webr}\n#| caption: Exercise 39\n#| exercise: e39\n```\n:::\n\n\n::: {.solution exercise=\"e39\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e39' solution='true'}\n```{webr}\n#| exercise: e39\n#| solution: true\nc_m <- rbind(cholera1, cholera2, cholera3, cholera4, cholera5)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e39' check='true'}\n```{webr}\n#| exercise: e39\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n::: {.cell setup='true' exercise='[\"e40\",\"e41\",\"e42\"]'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e40\n#|   - e41\n#|   - e42\nload(\"_static/data/cholera_merge.rda\")\nfor(i in 1:5) {\n  assign(paste0(\"cholera\", i), cholera_merge[cholera_merge$area == i, ])\n}\nc_m <- rbind(cholera1, cholera2, cholera3, cholera4, cholera5)\n```\n:::\n\n\nCheck it looks put back together with `head(c_m)`{.r}.\n\n\n::: {.cell caption='Exercise 40' exercise='e40'}\n```{webr}\n#| caption: Exercise 40\n#| exercise: e40\n```\n:::\n\n\n::: {.solution exercise=\"e40\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e40' solution='true'}\n```{webr}\n#| exercise: e40\n#| solution: true\nhead(c_m)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e40' check='true'}\n```{webr}\n#| exercise: e40\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n`NROW`{.r} tells you how many rows a dataset has. Does `c_m`{.r} have the same number as `cholera_merge`{.r}?\n\n`NROW(c_m) == NROW(cholera_merge)`{.r}\n\n\n::: {.cell caption='Exercise 41' exercise='e41'}\n```{webr}\n#| caption: Exercise 41\n#| exercise: e41\n```\n:::\n\n\n::: {.solution exercise=\"e41\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e41' solution='true'}\n```{webr}\n#| exercise: e41\n#| solution: true\nNROW(c_m) == NROW(cholera_merge)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e41' check='true'}\n```{webr}\n#| exercise: e41\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNot a perfect check, but looks good enough to convince us that we've probably\nreconstructed the data correctly. Now, let's say we wanted our data in a different format. Try this:\n\n`(threecho <- cbind(cholera1, cholera2, cholera3))`{.r}\n\n\n::: {.cell caption='Exercise 42' exercise='e42' envir='env2'}\n```{webr}\n#| caption: Exercise 42\n#| exercise: e42\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e42\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e42' solution='true'}\n```{webr}\n#| exercise: e42\n#| solution: true\n(threecho <- cbind(cholera1, cholera2, cholera3))\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e42' check='true'}\n```{webr}\n#| exercise: e42\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nSee a potential problem? The names of the columns are not unique. That's going to be an issue if you try to do some of the things we talked about because R won't know which one you want. You can examine the names of a dataset like this:\n\n`names(threecho)`{.r}\n\n\n::: {.cell caption='Exercise 43' exercise='e43' envir='env2'}\n```{webr}\n#| caption: Exercise 43\n#| exercise: e43\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e43\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e43' solution='true'}\n```{webr}\n#| exercise: e43\n#| solution: true\nnames(threecho)\n```\n:::\n\nIf you can't seem to get it to work, start again at Exercise 42.\n:::\n:::\n\n\n::: {.cell exercise='e43' check='true'}\n```{webr}\n#| exercise: e43\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nAnd you can change them with an assignment like this:\n\n`names(threecho) <- paste0(c(\"area\", \"subject\", \"age\", \"sex\"), rep(1:3, each = 4))`{.r}\n\nTry different parts from inside out before running it all if you can't immediately see what this does.\n\n\n::: {.cell caption='Exercise 44' exercise='e44' envir='env2'}\n```{webr}\n#| caption: Exercise 44\n#| exercise: e44\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e44\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e44' solution='true'}\n```{webr}\n#| exercise: e44\n#| solution: true\nnames(threecho) <- paste0(c(\"area\", \"subject\", \"age\", \"sex\"), rep(1:3, each = 4))\n```\n:::\n\nIf you can't seem to get it to work, start again at Exercise 42.\n:::\n:::\n\n\n::: {.cell exercise='e44' check='true'}\n```{webr}\n#| exercise: e44\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow take a look at `threecho`{.r} again.\n\n\n::: {.cell caption='Exercise 45' exercise='e45' envir='env2'}\n```{webr}\n#| caption: Exercise 45\n#| exercise: e45\n#| envir: env2\n```\n:::\n\n\n::: {.solution exercise=\"e45\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e45' solution='true'}\n```{webr}\n#| exercise: e45\n#| solution: true\nthreecho\n```\n:::\n\nIf you can't seem to get it to work, start again at Exercise 42.\n:::\n:::\n\n\n::: {.cell exercise='e45' check='true'}\n```{webr}\n#| exercise: e45\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nPretty spiffy, eh? Now let's turn to merging. This is usually what you want to do instead of `cbind`{.r} because order is not what matters, but making sure you\nare matching on the common variable(s) between the two datasets. Look at the head of another dataset you have available in this module: `cholera_disease`{.r}\n\n\n::: {.cell setup='true' exercise='[\"e46\",\"e47\"]'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e46\n#|   - e47\nload(\"_static/data/cholera_merge.rda\")\nload(\"_static/data/cholera_disease.rda\")\n```\n:::\n\n\n\n::: {.cell caption='Exercise 46' exercise='e46'}\n```{webr}\n#| caption: Exercise 46\n#| exercise: e46\n```\n:::\n\n\n::: {.solution exercise=\"e46\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e46' solution='true'}\n```{webr}\n#| exercise: e46\n#| solution: true\nhead(cholera_disease)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e46' check='true'}\n```{webr}\n#| exercise: e46\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nSince `cholera_disease` shares the `subject` variable with `cholera_merge` you can put the two together like this:\n\n`cmer <- merge(cholera_merge, cholera_disease)`{.r}\n\n\n::: {.cell caption='Exercise 47' exercise='e47'}\n```{webr}\n#| caption: Exercise 47\n#| exercise: e47\n```\n:::\n\n\n::: {.solution exercise=\"e47\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e47' solution='true'}\n```{webr}\n#| exercise: e47\n#| solution: true\ncmer <- merge(cholera_merge, cholera_disease)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e47' check='true'}\n```{webr}\n#| exercise: e47\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n::: {.cell setup='true' exercise='[\"e48\",\"e49\",\"e50\"]'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e48\n#|   - e49\n#|   - e50\nload(\"_static/data/cholera_merge.rda\")\nload(\"_static/data/cholera_disease.rda\")\ncmer <- merge(cholera_merge, cholera_disease)\n```\n:::\n\n\nNow check out the first 10 rows of `cmer`{.r} like this (the second argument to head specifies how many rows you want):\n\n`head(cmer, 10)`{.r}\n\n\n::: {.cell caption='Exercise 48' exercise='e48'}\n```{webr}\n#| caption: Exercise 48\n#| exercise: e48\n```\n:::\n\n\n::: {.solution exercise=\"e48\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e48' solution='true'}\n```{webr}\n#| exercise: e48\n#| solution: true\nhead(cmer, 10)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e48' check='true'}\n```{webr}\n#| exercise: e48\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nR automatically determines the common columns by finding the columns with the \nsame name in each `data.frame`{.r}, but what if no columns have the same name? Let's change the names of `cholera_disease`{.r} so none match `cholera_merge`{.r}. \n\n`names(cholera_disease) <- c(\"id\", \"disease\")`{.r}\n\n\n::: {.cell caption='Exercise 49' exercise='e49'}\n```{webr}\n#| caption: Exercise 49\n#| exercise: e49\n```\n:::\n\n\n::: {.solution exercise=\"e49\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e49' solution='true'}\n```{webr}\n#| exercise: e49\n#| solution: true\nnames(cholera_disease) <- c(\"id\", \"disease\")\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e49' check='true'}\n```{webr}\n#| exercise: e49\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nAnd merge:\n\n`cmer2 <- merge(cholera_merge, cholera_disease)`{.r}\n\n\n::: {.cell caption='Exercise 50' exercise='e50'}\n```{webr}\n#| caption: Exercise 50\n#| exercise: e50\n```\n:::\n\n\n::: {.solution exercise=\"e50\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e50' solution='true'}\n```{webr}\n#| exercise: e50\n#| solution: true\ncmer2 <- merge(cholera_merge, cholera_disease)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e50' check='true'}\n```{webr}\n#| exercise: e50\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nHow many rows does `cmer`{.r} have? (Not `cmer2`{.r}, but cmer{.r}.)\n\n\n::: {.cell setup='true' exercise='[\"e51\",\"e52\",\"e53\",\"e54\"]'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e51\n#|   - e52\n#|   - e53\n#|   - e54\nload(\"_static/data/cholera_merge.rda\")\nload(\"_static/data/cholera_disease.rda\")\ncmer <- merge(cholera_merge, cholera_disease)\nnames(cholera_disease) <- c(\"id\", \"disease\")\ncmer2 <- merge(cholera_merge, cholera_disease)\n```\n:::\n\n\n\n::: {.cell caption='Exercise 51' exercise='e51'}\n```{webr}\n#| caption: Exercise 51\n#| exercise: e51\n```\n:::\n\n\n::: {.hint exercise=\"e51\"}\n::: {.callout-note collapse=\"false\"}\n`NROW`{.r} is the function you need.\n:::\n:::\n\n::: {.solution exercise=\"e51\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e51' solution='true'}\n```{webr}\n#| exercise: e51\n#| solution: true\nNROW(cmer)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e51' check='true'}\n```{webr}\n#| exercise: e51\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nThat should make sense because `cholera_merge`{.r} had 25 rows and each one matched up with one in `cholera_disease`{.r}. But how many rows does `cmer2`{.r} have?\n\n\n::: {.cell caption='Exercise 52' exercise='e52'}\n```{webr}\n#| caption: Exercise 52\n#| exercise: e52\n```\n:::\n\n\n::: {.solution exercise=\"e52\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e52' solution='true'}\n```{webr}\n#| exercise: e52\n#| solution: true\nNROW(cmer2)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e52' check='true'}\n```{webr}\n#| exercise: e52\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nSo what happened? What is the square root of 625?\n(remember the `sqrt`{.r} function?)\n\n\n::: {.cell caption='Exercise 53' exercise='e53'}\n```{webr}\n#| caption: Exercise 53\n#| exercise: e53\n```\n:::\n\n\n::: {.solution exercise=\"e53\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e53' solution='true'}\n```{webr}\n#| exercise: e53\n#| solution: true\nsqrt(625)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e53' check='true'}\n```{webr}\n#| exercise: e53\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhat happened? Since there were no common columns R created the merge by combining every observation in the first `data.frame`{.r} with each observation in the second: $25 \\times 25 = 625$. Let's inform R what columns we want to match on by using some optional arguments of `merge`{.r} (definitely take a look at `merge`{.r}'s help at some point). The `by.x` argument refers to the first `data.frame`'s variables and the `by.y` argument refers to the second `data.frame`'s variables in `merge`{.r}'s arguments (when you look at the help you'll see that the first argument is named `x` and the second is `y`).\n\nNow merge again like this instead:\n\n`NROW(merge(cholera_merge, cholera_disease, by.x = \"subject\", by.y = \"id\"))`{.r}\n\n\n::: {.cell caption='Exercise 54' exercise='e54'}\n```{webr}\n#| caption: Exercise 54\n#| exercise: e54\n```\n:::\n\n\n::: {.solution exercise=\"e54\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e54' solution='true'}\n```{webr}\n#| exercise: e54\n#| solution: true\nNROW(merge(cholera_merge, cholera_disease, by.x = \"subject\", by.y = \"id\"))\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e54' check='true'}\n```{webr}\n#| exercise: e54\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nLooks like we have an expected, correct merge again; indeed you do, and I'll let you convince yourself later if you need to. What if, instead, all the rows are not in both datasets? Let's create a small sample (only 5 rows) from the original `cholera_disease`{.r} dataset. \n\n\n::: {.cell setup='true' exercise='e55'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e55\nload(\"_static/data/cholera_disease.rda\")\n```\n:::\n\n\nIn the code below, the `set.seed`{.r} function makes sure you get the same random sample each time you run the code. Let's talk more in class about how random sampling works in computers.  Then, we use `sample`{.r} to randomly select 5 row numbers from one to the number of rows in `cholera_disease`{.r} obtained by the `NROW`{.r} function. Finally we use those row numbers to subset `cholera_disease`{.r} to create `cdsamp`{.r}.\n\n\n::: {.cell caption='Exercise 55' exercise='e55'}\n```{webr}\n#| caption: Exercise 55\n#| exercise: e55\nset.seed(596) \ncdsamp <- cholera_disease[sample(NROW(cholera_disease), 5), ]\n```\n:::\n\n\n::: {.solution exercise=\"e55\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e55' solution='true'}\n```{webr}\n#| exercise: e55\n#| solution: true\nset.seed(596) \ncdsamp <- cholera_disease[sample(NROW(cholera_disease), 5), ]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e55' check='true'}\n```{webr}\n#| exercise: e55\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nMerge it with cholera_merge like this:\n\n`merge(cholera_merge, cdsamp)`{.r}\n\n\n::: {.cell setup='true' exercise='[\"e56\",\"e57\"]'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e56\n#|   - e57\nload(\"_static/data/cholera_disease.rda\")\nload(\"_static/data/cholera_merge.rda\")\nset.seed(596) \ncdsamp <- cholera_disease[sample(NROW(cholera_disease), 5), ]\n```\n:::\n\n\n\n::: {.cell caption='Exercise 56' exercise='e56'}\n```{webr}\n#| caption: Exercise 56\n#| exercise: e56\n```\n:::\n\n\n::: {.solution exercise=\"e56\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e56' solution='true'}\n```{webr}\n#| exercise: e56\n#| solution: true\nmerge(cholera_merge, cdsamp)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e56' check='true'}\n```{webr}\n#| exercise: e56\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nHoly disappearing rows, Batman! Looks like `merge`{.r} only keeps the matches. \nBy default, that's true, so be careful and be sure to specify another option if you want to keep all the rows of one of the two datasets (or both). Use the `all.x = TRUE`{.r} argument to keep all the rows of the first `data.frame`{.r}, `all.y = TRUE`{.r} to keep all the rows of the second `data.frame`{.r}, or `all = TRUE`{.r} to keep all rows of both. As an example, try this:\n\n`(merall <- merge(cholera_merge, cdsamp, all.x = TRUE))`{.r}\n\n\n::: {.cell caption='Exercise 57' exercise='e57'}\n```{webr}\n#| caption: Exercise 57\n#| exercise: e57\n```\n:::\n\n\n::: {.solution exercise=\"e57\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e57' solution='true'}\n```{webr}\n#| exercise: e57\n#| solution: true\n(merall <- merge(cholera_merge, cdsamp, all.x = TRUE))\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e57' check='true'}\n```{webr}\n#| exercise: e57\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nAll the rows from the first `data.frame`, i.e., `x`, are there with missing data from the second `data.frame`, i.e., `y`, represented by `NA`{.r}. \n\nUntil you gain more familiarity you should probably merge with `all = TRUE`{.r} because those `NA`'s will save you a lot of heartache when you are merging datasets that you do not realize are incompatible somehow.\n\n### Sorting vectors and data frames\n\nOK, next topic for this exercise, i.e., sorting. Sort a `vector`{.r} like this:\n\n`sort(merall$age)`{.r}\n\n\n::: {.cell setup='true' exercise='[\"e58\",\"e59\",\"e60\",\"e61\",\"e62\",\"e63\",\"e64\",\"e65\",\"e66\",\"e67\"]'}\n```{webr}\n#| setup: true\n#| exercise: \n#|   - e58\n#|   - e59\n#|   - e60\n#|   - e61\n#|   - e62\n#|   - e63\n#|   - e64\n#|   - e65\n#|   - e66\n#|   - e67\nload(\"_static/data/cholera_disease.rda\")\nload(\"_static/data/cholera_merge.rda\")\nset.seed(596) \ncdsamp <- cholera_disease[sample(NROW(cholera_disease), 5), ]\nmerall <- merge(cholera_merge, cdsamp, all.x = TRUE)\n```\n:::\n\n\n\n::: {.cell caption='Exercise 58' exercise='e58'}\n```{webr}\n#| caption: Exercise 58\n#| exercise: e58\n```\n:::\n\n\n::: {.solution exercise=\"e58\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e58' solution='true'}\n```{webr}\n#| exercise: e58\n#| solution: true\nsort(merall$age)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e58' check='true'}\n```{webr}\n#| exercise: e58\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nIt is a little trickier if you want to reorder a `data.frame`{.r} by one of its variables. For that you need the order function, try it:\n\n`order(merall$age)`{.r}\n\n\n::: {.cell caption='Exercise 59' exercise='e59'}\n```{webr}\n#| caption: Exercise 59\n#| exercise: e59\n```\n:::\n\n\n::: {.solution exercise=\"e59\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e59' solution='true'}\n```{webr}\n#| exercise: e59\n#| solution: true\norder(merall$age)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e59' check='true'}\n```{webr}\n#| exercise: e59\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWhat in the world is going on here? Look at `merall$age`{.r} and compare to the output you just got.\n\n\n::: {.cell caption='Exercise 60' exercise='e60'}\n```{webr}\n#| caption: Exercise 60\n#| exercise: e60\n```\n:::\n\n\n::: {.solution exercise=\"e60\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e60' solution='true'}\n```{webr}\n#| exercise: e60\n#| solution: true\nmerall$age\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e60' check='true'}\n```{webr}\n#| exercise: e60\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nOK, what is the 2nd value of `merall$age`{.r}? The 11th? The 18th? The 6th? Maybe you should write them down. Do you see how order tells you which values to take to sort `merall$age`{.r}?\n\nIf fact, you can sort `merall$age`{.r} like this:\n\n`merall$age[order(merall$age)]`{.r}\n\n\n::: {.cell caption='Exercise 61' exercise='e61'}\n```{webr}\n#| caption: Exercise 61\n#| exercise: e61\n```\n:::\n\n\n::: {.solution exercise=\"e61\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e61' solution='true'}\n```{webr}\n#| exercise: e61\n#| solution: true\nmerall$age[order(merall$age)]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e61' check='true'}\n```{webr}\n#| exercise: e61\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nThe `order`{.r} function is more useful for a `data.frame`{.r} where it can be used to sort the data.frame by one of its variables. Sort `merall`{.r} by age:\n\n`merall[order(merall$age), ]`{.r}\n\n\n::: {.cell caption='Exercise 62' exercise='e62'}\n```{webr}\n#| caption: Exercise 62\n#| exercise: e62\n```\n:::\n\n\n::: {.solution exercise=\"e62\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e62' solution='true'}\n```{webr}\n#| exercise: e62\n#| solution: true\nmerall[order(merall$age), ]\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e62' check='true'}\n```{webr}\n#| exercise: e62\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n### Can you make heads or tails of it?\n\nOK, last new topic - getting the first and last items of a vector or data.frame. You've seen `head`{.r} which gets the first values of a vector or the first rows of a `data.frame`{.r}. It is 6 values or rows by default:\n\n`head(merall)`{.r}\n\n\n::: {.cell caption='Exercise 63' exercise='e63'}\n```{webr}\n#| caption: Exercise 63\n#| exercise: e63\n```\n:::\n\n\n::: {.solution exercise=\"e63\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e63' solution='true'}\n```{webr}\n#| exercise: e63\n#| solution: true\nhead(merall)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e63' check='true'}\n```{webr}\n#| exercise: e63\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nWant more or less? Use the second argument:\n\n`head(merall, 10)`{.r}\n\n\n::: {.cell caption='Exercise 64' exercise='e64'}\n```{webr}\n#| caption: Exercise 64\n#| exercise: e64\n```\n:::\n\n\n::: {.solution exercise=\"e64\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e64' solution='true'}\n```{webr}\n#| exercise: e64\n#| solution: true\nhead(merall, 10)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e64' check='true'}\n```{webr}\n#| exercise: e64\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nThe `tail`{.r} function works just like `head`{.r} but gives you the end rather than the top.\n\n`tail(merall, 10)`{.r}\n\n\n::: {.cell caption='Exercise 65' exercise='e65'}\n```{webr}\n#| caption: Exercise 65\n#| exercise: e65\n```\n:::\n\n\n::: {.solution exercise=\"e65\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e65' solution='true'}\n```{webr}\n#| exercise: e65\n#| solution: true\ntail(merall, 10)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e65' check='true'}\n```{webr}\n#| exercise: e65\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nYou can use negative numbers to get \"all but\" from the relevant end. So with `head`{.r} you get all the rows at the top minus that number of rows.\n\nThis will give you all but the last five rows:\n\n`head(merall, -5)`{.r}\n\n\n::: {.cell caption='Exercise 66' exercise='e66'}\n```{webr}\n#| caption: Exercise 66\n#| exercise: e66\n```\n:::\n\n\n::: {.solution exercise=\"e66\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e66' solution='true'}\n```{webr}\n#| exercise: e66\n#| solution: true\nhead(merall, -5)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e66' check='true'}\n```{webr}\n#| exercise: e66\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nAnd `tail`{.r} again works like `head`{.r} - so this is all but the first 15 rows\n\n`tail(merall, -15)`{.r}\n\n\n::: {.cell caption='Exercise 67' exercise='e67'}\n```{webr}\n#| caption: Exercise 67\n#| exercise: e67\n```\n:::\n\n\n::: {.solution exercise=\"e67\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e67' solution='true'}\n```{webr}\n#| exercise: e67\n#| solution: true\ntail(merall, -15)\n```\n:::\n\n:::\n:::\n\n\n::: {.cell exercise='e67' check='true'}\n```{webr}\n#| exercise: e67\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n::: {.cell type='open-on-pass' exercise='67'}\n```{adm}\n#| type: open-on-pass\n#| exercise: 67\nOK, that's a lot of review and new material!  You've done great!  Time for a break!!!\n```\n:::\n\n\n## Evaluation\n\n### Submit Your Assignment\n\n\n::: {.cell type='progress-submit'}\n```{adm}\n#| type: progress-submit\n```\n:::\n\n::: {#adm-progress-submit}\n\n::: {.cell autorun='true'}\n```{webr}\n#| autorun: true\n.progress_submit(\"07-Food-Prep\", 67)\n```\n:::\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}