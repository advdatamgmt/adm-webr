{
  "hash": "13b48375414f0b6085af4aa412745185",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advanced Table Example\"\norder: 950\nwebr:\n  cell-options:\n    autorun: true\n  packages:\n    - htmltools\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\n###########################################################\n# if you edit this section note there is an `r` block below too\n.course_id <- readLines(\"_static/data/course_id.txt\")\n.assignment_ids <- dget(\"_static/data/assignment_ids.txt\")\n.canvas_link <- function(a) glue::glue(\"https://canvas.emory.edu/courses/{.course_id}/assignments/{.assignment_ids[{a}]}\")\n############################################################\n.webr_progress <- data.frame(label = character(), user_code = character(), solution_code = character(), result = logical())\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    res <- gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n    .webr_progress <<- rbind(\n      .webr_progress,\n      data.frame(\n        label = label,\n        user_code = user_code,\n        solution_code = solution_code,\n        result = res$correct\n      )\n    )\n    res\n  }\n})\n.csv_data_uri <- function(df) {\n  enc_csv <- base64enc::base64encode(\n    charToRaw(\n      paste(\n        capture.output(\n          write.csv(df)),\n          collapse = \"\\n\")\n    )\n  )\n  glue::glue(\"data:text/csv;base64,{enc_csv}\")\n}\n.save_restore_progress <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::tags$a(\n      download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n      href = .csv_data_uri(df),\n      htmltools::tags$button(\n          #onClick = \"this.classList.add('clicked');\",\n          class = \"btn progress-submit\",\n          \"Save progress\",\n          .noWS = \"outside\"\n      )\n    ),\n    htmltools::tags$label(\n      `for` = \"restore-file-input\",\n      type = \"button\",\n      id = \"restore-progress-button\",\n      class = \"btn progress-submit btn-quarto\",\n      onClick = \"restore_listener();\",\n      \"Restore progress\"\n    ),\n    htmltools::tags$input(\n      type = \"file\",\n      id = \"restore-file-input\",\n      style = \"display: none\",\n      accept = \".csv\"\n    )\n  )\n}\n.steps_to_submit <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::p(\n      htmltools::strong(\"Steps to submit:\")\n    ),\n    htmltools::tags$ol(\n        htmltools::tags$li(\n        \"Save your work to your device by clicking: \",\n        htmltools::tags$a(\n            download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n            href = .csv_data_uri(df),\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Download\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"Go to related Canvas assignment (note this will open a new tab or window and you may need to login) by clicking:\",\n        htmltools::tags$a(\n            href = .canvas_link(assignment_name),\n            target = \"_blank\",\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Open Canvas Assignment\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"On the page that just opened find and click on a button\",\n        \"that looks like this in the upper right corner:\",\n        htmltools::tags$img(\n            src = \"../_static/canvas_start_assignment.png\",\n            alt = \"Start Assignment Button\",\n            style = \"max-width: 200px; border: 1px solid black; margin-left: 1em;\"\n        )\n        ),\n        htmltools::tags$li(\n        htmltools::p(\"After you click you should see the following:\"),\n        htmltools::tags$img(\n            src = \"../_static/canvas_submission.png\",\n            alt = \"Submit Assignment Image\",\n            style = \"max-width: 400px; border: 1px solid black; margin-left: 5em;\"\n        ),\n        htmltools::p(\n            \"Either drag the file you saved in the first step or click \",\n            \"\\\"Choose a file to upload\\\" under the rocket drawing \",\n            \"to find the file.\"\n        )\n        ),\n        htmltools::tags$li(\n        \"Finally, click the \\\"Submit Assignment\\\" button.\"\n        )\n    )\n  )\n}\n.progress_submit <- function(assignment_name, n_exercises, progress_obj = .webr_progress) {\n  all <- as.character(1:n_exercises)\n  done <- gsub(\"e\", \"\", sort(unique(progress_obj$label[progress_obj$result])))\n  todo <- setdiff(all, done)\n  collapse_runs <- function(x) {\n    x <- as.integer(x)\n    out <- character()\n    for (i in seq_along(x)) {\n      if (i == 1) {\n        run_start <- run_end <- x[i]\n        next\n      }\n      if (x[i] == run_end + 1) {\n        run_end <- x[i]\n      } else {\n        if (run_start == run_end) {\n          out <- c(out, as.character(run_start))\n        } else {\n          out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n        }\n        run_start <- run_end <- x[i]\n      }\n    }\n    if (run_start == run_end) {\n      out <- c(out, as.character(run_start))\n    } else {\n      out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n    }\n    out\n  }\n  collapse_nums <- function(x) {\n    x <- collapse_runs(x)\n    if (length(x) == 1) {\n      return(x)\n    } else if (length(x) == 2) {\n      return(glue::glue(\"{x[1]} and {x[2]}\"))\n    } else {\n      return(glue::glue_collapse(x, \", \", last = \", and \"))\n    }\n  }\n  if (length(todo) > 0) {\n    htmltools::div(\n      htmltools::tags$p(\n        glue::glue(\n          \"Before you can submit you still need correctly complete exercises \",\n          collapse_nums(todo),\n          \".\"\n          ),\n          style = \"color: red; font-weight: bold;\"\n      ),\n      .save_restore_progress(assignment_name)\n    )\n  } else {\n    htmltools::div(\n      htmltools::p(\n        \"All done! You can submit now!\",\n        style = \"color: green; font-weight: bold;\"\n      ),\n    .steps_to_submit(assignment_name)\n    )\n  }\n}\n```\n:::\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Introduction\n\nHerein we create a more advanced table that would be suitable \nfor inclusion a final report or manuscript.  The table is formatted completely \nin a way that you would expect to see in a published manuscript or official \nreport using [HTML, the main language that creates webpages](https://www.w3schools.com/html/).\n\nThe amount of work that generally goes into creating a table like this is \nsubstantial, so I would only suggest you use this approach for a report that\nyou expect to be publishing on a regular basis or for a report or manuscript\nin development which has frequent changes to the underlying data or analysis.\n\nWe will use the `lbw` dataset which is included in this dataset. This dataset\ncontains data on low birth weight (lbw) babies and various maternal risk factors \nand was used in the book *Applied Logistic Regression* by Hosmer and\nLemeshow.  Take a look at the dataset.\n\n\n::: {.cell}\n```{webr}\n#| echo: false\nload(\"_static/data/lbw.rda\")\n```\n:::\n\n\n\n::: {.cell}\n```{webr}\nhead(lbw)\nsummary(lbw)\n```\n:::\n\n\nWe need to create some derived variables for the table.  \n\n\n::: {.cell}\n```{webr}\nlbw <- within(lbw, {\n  age.lte20 <- factor(ifelse(age <= 20, 1, 0))\n  lwt.lt110 <- factor(ifelse(lwt < 110 ,1, 0))\n  ptl.ge1 <- factor(ifelse(ptl != \"0\", 1, 0))\n  ftv.ge1 <- factor(ifelse(ftv != \"0\", 1, 0))\n  race.black <- factor(ifelse(race == \"black\", 1, 0))\n  race.white <- factor(ifelse(race == \"white\", 1, 0))\n  race.other <- factor(ifelse(race == \"other\", 1, 0))\n})\n```\n:::\n\n\n## Create the formatted table data\n\nI've determined that I'm going to need eight columns in my table, and I'll \ntherefore start building by creating a `data.frame` with eight character columns.\nBeacause I'm going to be creating the entire table instead of using a table \nshell in Word, I'll just go ahead and put my column headers in, noting that\nsome are blank.\n\n\n::: {.cell}\n```{webr}\nsum_table <- data.frame(\n  varname = \"Variable\",\n  lbw_n = \"n\", \n  lbw_pct = \"%\",\n  div = \"\",\n  non_lbw_n = \"n\",\n  non_lbw_pct = \"%\",\n  chisq = \"𝜒²\",\n  pval = \"p†\"\n)\n\nsum_table\n```\n:::\n\n\nAdd in the table rows one at a time, but first add a couple of helper functions.\n\nA function to format p-values with appropriate number of decimal places. You'll\ndefinitely want to keep this function handy for future use!  The special comments\nare a way to document your functions in your R code in a standard way that can\ncreate help files later if you wish using [roxygen2](https://roxygen2.r-lib.org/).\n\n::: {.cell}\n```{webr}\n#' Format a p-value\n#'\n#' Formats a p-value with `usual.places` number of digits unless \n#' it is smaller, then displays up to `max.places`.  Uses \n#  `sig.level` to add a digit when the value is borderline \n#' (i.e., rounds up to `sig.level`).\n#'\n#' @param p.value p-value to be formatted\n#' @param usual.places number of decimal places to usually display\n#' @param max.places the most decimal places to display\n#' @param sig.level the significance level\n#' @param print.p print \"p = \"?\nfmt_pval <- function(p.value, usual.places = 2, max.places = 3, \n                     sig.level = 0.05, print.p = FALSE) {\n  if(is.nan(p.value)) return(NaN)\n  comp <- if (print.p) \"=\" else \"\"\n  spfstr <- \"%f\"\n  if (round(p.value, usual.places) < 10^(-usual.places)) {\n    if(p.value < 10^(-max.places)) {\n      comp <- \"<\"\n      p.value <- 10^(-max.places)\n      spfstr <- paste0(\"%.\", max.places, \"f\")\n    } else {\n      spfstr <- paste0(\"%.\",max.places,\"f\")\n    }\n  } else {\n    if(round(p.value, usual.places) == sig.level) {\n      spfstr <- paste0(\"%.\", usual.places + 1 ,\"f\")\n    } else {\n      spfstr <- paste0(\"%.\", usual.places, \"f\")\n    }\n  }\n  paste0(if(print.p) \"p \" else \"\", comp, sprintf(spfstr, p.value))\n}\n```\n:::\n\n\nA function to figure out autmomatically if the chi-square test is appropriate or if\nwe need to use Fisher's exact test, reporting he correctly formatted result for\nour table.  Note how we use the internals of the `summary` function's results to \ndecide how to proceed.\n\n\n::: {.cell}\n```{webr}\ncat_test <- function(tab) {\n  stats <- summary(tab)\n  if(stats$approx.ok) {\n    chisq <- sprintf(\"%.2f\", stats$statistic)\n    pval <- stats$p.value\n    twotail <- \"\"\n  } else {\n    chisq <- \"‡\"\n    pval <- fisher.test(tab)$p.value\n    twotail <- \"§\"\n  }\n\n  list(chisq = chisq, pval = paste0(fmt_pval(pval), twotail))\n}\n```\n:::\n\n\nNow the main rows.  Start with a vector that holds the formatted variable names\nand associate units as appropriate. Use `row_names` so you don't clash with \nthe built-in `rownames` function.\n\n\n::: {.cell}\n```{webr}\nrow_names <- list(\n  age.lte20 = \"Age of mother, ≤20 years\", \n  race = \"Race\", \n  race.black = list(HTML(\"&nbsp;\"), \"-\", HTML(\"&nbsp;\"), \"Black\"), \n  race.white = list(HTML(\"&nbsp;\"), \"-\", HTML(\"&nbsp;\"), \"White\"), \n  race.other = list(HTML(\"&nbsp;\"), \"-\", HTML(\"&nbsp;\"), \"Other\"), \n  lwt.lt110 = \"Weight at last menstrual period <110 lbs\", \n  ptl.ge1 = \"History of premature labor\", \n  smoke = \"Smoked during pregnancy\", \n  ht = \"History of hypertension\", \n  ui = \"History of uterine irritability\", \n  ftv.ge1 = \"At least one physician visit during first trimester\"\n)\n```\n:::\n\n\nCreate a function to make each formatted row.\n\n\n::: {.cell}\n```{webr}\nrow_builder <- function(varname) {\n  if(varname == \"race\") return(c(row_names[varname], rep(\"\", 7)))\n  tab <- table(lbw[, varname], lbw$low)\n  props <- sprintf(\"%.1f\", prop.table(tab, 2)[2, ]*100)\n  stats <- cat_test(tab)\n  c(row_names[varname], tab[2, 2], props[2], \"\", tab[2, 1], props[1], stats$chisq, stats$pval)\n}\n```\n:::\n\n\nNow put this together with some fancy footwork.\n\n\n::: {.cell}\n```{webr}\nrows <- lapply(names(row_names), row_builder)\nrows <- as.data.frame(do.call(rbind, rows))\nnames(rows) <- names(sum_table)\nsum_table <- rbind(sum_table, rows)\n```\n:::\n\n\nThat looks great!  We just need to put in the headers that span across the\nlow birth weight and non-low birth weight columns.  To make those, we need to\nget the sample sizes for each group.  See how I get pull them from the data\nvs. hard coding them.\n\n\n::: {.cell}\n```{webr}\nn <- summary(lbw$low)\nn0str <- paste0(\"n=\", n[\"0\"])\nn1str <- paste0(\"n=\", n[\"1\"])\n\nn0str\nn1str\n```\n:::\n\n\n## Create the HTML table\n\nNow, we have all the formatted data we need to create the HTML table.\nLet's load a package that will help us create HTML elements, `htmltools`.\n\n\n::: {.cell}\n```{webr}\nlibrary(htmltools)\n```\n:::\n\n\nIn HTML, the `<table>`{.html} element is made up of rows (`<tr>`{.html} elements) which\nare made up of cells.  There are two types of cells, header cells (`<th>`{.html})\nand data cells (`<td>`{.html}).  These have different default formatting in HTML, and\nallows us to independenly change the look of the header cells vs. the data cells \nif we wish.  We will also specify some formatting attributes in the cells using\n[CSS (i.e., cascading style sheets)](https://www.w3schools.com/css/) which is the \nlanguage used to format HTML elements.\n\nWe will apply make `<th>`{.html} elements for the first row and put a border on the bottom\nof that row `<tr>`{.html} using CSS.  For the remaining rows, we will use `<td>`{.html} elements,\nbut will put a border on the last `<tr>`{.html}.  We will use a `for`{.r} loop to\ncreate the rows because we want to apply something different to different rows and\n`lapply`{.r} works best when we want to do the same thing to each element.\n\nHowever, we will use `lapply`{.r} in the `for`{.r} loop to apply the `<th>`{.html} and the `<td>`{.html} \nto the individual cells within each row since there we are doing the same thing to each\ncell.\n\n\n::: {.cell}\n```{webr}\nsum_html <- list()\nfor (i in 1:NROW(sum_table)) {\n  if (i == 1) {  # first row\n    cell_func <- tags$th\n    row_style <- \"border-bottom: black solid\"\n  } else if (i == NROW(sum_table)) { # last row \n    cell_func <- tags$td\n    row_style <- \"border-bottom: black solid\"\n  } else {\n    cell_func <- tags$td\n    row_style <- NULL\n  }\n  sum_html[[i]] <- tags$tr(\n    lapply(sum_table[i, ], cell_func),\n    style = row_style\n  )\n}\n```\n:::\n\n\nBuild our fixed spanning headers. The `&nbsp;`{.html} below are something that are likely new to you.  It represents a\n[non-breaking space](https://www.geeksforgeeks.org/html/how-to-add-a-non-breaking-space-using-nbsp-in-html/) \nin HTML.  If we don't use them, HTML will collapse multiple spaces into a single space\nwhen it renders the table.  Their use here is simply to add some padding to the\nempty column in the middle of the table for readability.  We only have to do it \nin one place because it will expand the rest of that column overall. \n\nOne could cut-and-paste the [Unicode character for the non-breaking space](https://unicode-explorer.com/c/00A0), but\nbecause it looks like a space (here's one now in the quotes \" \") using them\nthat way is a bit opaque.\n\n\n::: {.cell}\n```{webr}\nspan_header <- list(\n  tags$tr(\n    tags$th(),\n    tags$th(\"Low birth weight\", colspan = 2, style = \"text-align: center;\"),\n    tags$th(HTML(\"&nbsp;&nbsp;&nbsp;\")),\n    tags$th(\"Non-low birth weight\", colspan = 2, style = \"text-align: center;\"),\n    tags$th(),\n    tags$th()\n  ),\n  tags$tr(\n    tags$th(),\n    tags$th(n1str, colspan = 2, style = \"text-align: center; border-bottom: black solid;\"),\n    tags$th(),\n    tags$th(n0str, colspan = 2, style = \"text-align: center; border-bottom: black solid;\"),\n    tags$th(),\n    tags$th()\n  )  \n)\n```\n:::\n\n\nFinally, some footnotes.\n\n\n::: {.cell}\n```{webr}\nfootnotes <- c(\n  \"† α=0.05. Significant p-values are marked with an asterisk (*).\", \n  \"‡ Fisher's Exact Test\", \n  \"§ Two-tailed p-value\"\n)\n```\n:::\n\n\nAnd all together now plus a caption!  Line break tags `<br>`{.html} go *between* we don't \napply the function to each footnote. \n\n\n::: {.cell}\n```{webr}\ntags$caption(\n  style = \"caption-side: top; text-align: left; font-weight: bold;\",\n\"<b>Table 1.</b> Frequency of exposures in cases of low birth \\\n         weight (&lt;2500 g) vs. non-low birth weight.\", \"p\")\n\n\ntags$table(\n  span_header,\n  sum_html)\ntags$p(\n  lapply(footnotes, function(x) list(x, tags$br())),\n  style = \"small\"\n)\n```\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}