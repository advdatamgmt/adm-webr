{
  "hash": "e78fb1cbc98fd3105e931803eba7bb55",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Grammar of Graphics\"\norder: 1000\nwebr:\n  packages:\n    - ggplot2\n  cell-options:\n    autorun: true\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\n###########################################################\n# if you edit this section note there is an `r` block below too\n.course_id <- readLines(\"_static/data/course_id.txt\")\n.assignment_ids <- dget(\"_static/data/assignment_ids.txt\")\n.canvas_link <- function(a) glue::glue(\"https://canvas.emory.edu/courses/{.course_id}/assignments/{.assignment_ids[{a}]}\")\n############################################################\n.webr_progress <- data.frame(label = character(), user_code = character(), solution_code = character(), result = logical())\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    res <- gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n    .webr_progress <<- rbind(\n      .webr_progress,\n      data.frame(\n        label = label,\n        user_code = user_code,\n        solution_code = solution_code,\n        result = res$correct\n      )\n    )\n    res\n  }\n})\n.csv_data_uri <- function(df) {\n  enc_csv <- base64enc::base64encode(\n    charToRaw(\n      paste(\n        capture.output(\n          write.csv(df)),\n          collapse = \"\\n\")\n    )\n  )\n  glue::glue(\"data:text/csv;base64,{enc_csv}\")\n}\n.save_restore_progress <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::tags$a(\n      download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n      href = .csv_data_uri(df),\n      htmltools::tags$button(\n          #onClick = \"this.classList.add('clicked');\",\n          class = \"btn progress-submit\",\n          \"Save progress\",\n          .noWS = \"outside\"\n      )\n    ),\n    htmltools::tags$label(\n      `for` = \"restore-file-input\",\n      type = \"button\",\n      id = \"restore-progress-button\",\n      class = \"btn progress-submit btn-quarto\",\n      onClick = \"restore_listener();\",\n      \"Restore progress\"\n    ),\n    htmltools::tags$input(\n      type = \"file\",\n      id = \"restore-file-input\",\n      style = \"display: none\",\n      accept = \".csv\"\n    )\n  )\n}\n.steps_to_submit <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::p(\n      htmltools::strong(\"Steps to submit:\")\n    ),\n    htmltools::tags$ol(\n        htmltools::tags$li(\n        \"Save your work to your device by clicking: \",\n        htmltools::tags$a(\n            download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n            href = .csv_data_uri(df),\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Download\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"Go to related Canvas assignment (note this will open a new tab or window and you may need to login) by clicking:\",\n        htmltools::tags$a(\n            href = .canvas_link(assignment_name),\n            target = \"_blank\",\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Open Canvas Assignment\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"On the page that just opened find and click on a button\",\n        \"that looks like this in the upper right corner:\",\n        htmltools::tags$img(\n            src = \"../_static/canvas_start_assignment.png\",\n            alt = \"Start Assignment Button\",\n            style = \"max-width: 200px; border: 1px solid black; margin-left: 1em;\"\n        )\n        ),\n        htmltools::tags$li(\n        htmltools::p(\"After you click you should see the following:\"),\n        htmltools::tags$img(\n            src = \"../_static/canvas_submission.png\",\n            alt = \"Submit Assignment Image\",\n            style = \"max-width: 400px; border: 1px solid black; margin-left: 5em;\"\n        ),\n        htmltools::p(\n            \"Either drag the file you saved in the first step or click \",\n            \"\\\"Choose a file to upload\\\" under the rocket drawing \",\n            \"to find the file.\"\n        )\n        ),\n        htmltools::tags$li(\n        \"Finally, click the \\\"Submit Assignment\\\" button.\"\n        )\n    )\n  )\n}\n.progress_submit <- function(assignment_name, n_exercises, progress_obj = .webr_progress) {\n  all <- as.character(1:n_exercises)\n  done <- gsub(\"e\", \"\", sort(unique(progress_obj$label[progress_obj$result])))\n  todo <- setdiff(all, done)\n  collapse_runs <- function(x) {\n    x <- as.integer(x)\n    out <- character()\n    for (i in seq_along(x)) {\n      if (i == 1) {\n        run_start <- run_end <- x[i]\n        next\n      }\n      if (x[i] == run_end + 1) {\n        run_end <- x[i]\n      } else {\n        if (run_start == run_end) {\n          out <- c(out, as.character(run_start))\n        } else {\n          out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n        }\n        run_start <- run_end <- x[i]\n      }\n    }\n    if (run_start == run_end) {\n      out <- c(out, as.character(run_start))\n    } else {\n      out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n    }\n    out\n  }\n  collapse_nums <- function(x) {\n    x <- collapse_runs(x)\n    if (length(x) == 1) {\n      return(x)\n    } else if (length(x) == 2) {\n      return(glue::glue(\"{x[1]} and {x[2]}\"))\n    } else {\n      return(glue::glue_collapse(x, \", \", last = \", and \"))\n    }\n  }\n  if (length(todo) > 0) {\n    htmltools::div(\n      htmltools::tags$p(\n        glue::glue(\n          \"Before you can submit you still need correctly complete exercises \",\n          collapse_nums(todo),\n          \".\"\n          ),\n          style = \"color: red; font-weight: bold;\"\n      ),\n      .save_restore_progress(assignment_name)\n    )\n  } else {\n    htmltools::div(\n      htmltools::p(\n        \"All done! You can submit now!\",\n        style = \"color: green; font-weight: bold;\"\n      ),\n    .steps_to_submit(assignment_name)\n    )\n  }\n}\n```\n:::\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Exposition\n\n### Install ggplot2\n\nGrammar of graphics is found in the package `ggplot2`.  \n\nTo install it for the first time, run the following code.\n\n\n::: {.cell autorun='false' edit='false'}\n```{webr}\n#| autorun: false\n#| edit: false\ninstall.packages(\"ggplot2\")\n```\n:::\n\n\nTo load the package so you can use it, run this code every time you start R or \nat the start of your script or Quarto document.\n\n\n::: {.cell}\n```{webr}\nlibrary(ggplot2)\n```\n:::\n\n\n### Using ggplot2\n\nThe function is called `ggplot`. Note that there is no number `2` on the end of the\nfunction name like the package name. \n\nYou will need to refer frequently to the [`ggplot2` documentation](https://ggplot2.tidyverse.org/).  \n\nThe plotting functions list \"aesthetics\" that connect data to visual\nproperties of the graph, e.g., x and y positions, colors, shapes, sizes,\netc.  This list of aesthetics for each function is displayed in addition to the \nusual \"arguments\"  that all R functions have.  \n\nAesthetics are placed within a function\ncalled `aes` that you put within various `ggplot2` function calls as an argument.\nWatch for that pattern below as we work to recreate a version of our optic nerve\nhead figure and for which I've already loaded the data.\n\n\n::: {.cell autorun='true'}\n```{webr}\n#| autorun: true\n#| echo: false\nload(\"_static/data/onhlong.rda\")\nload(\"_static/data/onhfit.rda\")\nload(\"_static/data/rop.rda\")\n```\n:::\n\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean))\n```\n:::\n\n\nAn example of using `aes` already! Here we are creating a `ggplot`{.r} object\nusing the `onhlong`{.r} dataset and telling ggplot that the `age`{.r} variable\nrepresents the x-axis position and the `mean`{.r} variable represents the \ny-axis position for any of the functions that are applied to this `ggplot`{.r}\nobject, and it produces a blank plot with the axes set up correctly for our data\nand its ranges. \n\nNext, we add a layer that plots the points:\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) + \n  geom_point()\n```\n:::\n\n\nMost layers that draw things are prefixed with `geom_`  There are many, many\nkinds; see that documentation we linked above for details. How does `geom_point`{.r}\nknow where to put the points? It uses the aesthetics we defined in the original\n`ggplot`{.r} call.\n\n#### More aesthetics\n\nBut we want the different points to have different colors depending on the\ngroups right?  This is a another aesthetic ([see the documentation for\n`geom_point`{.r}](https://ggplot2.tidyverse.org/reference/geom_point.html#aesthetics) \nfor more details on this and other aesthetics you can control).\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) + \n  geom_point(aes(color = case))\n```\n:::\n\n\nWe could put the `color = case`{.r} aesthetic in the original `ggplot`{.r} call, but\nputting it here means it only applies to this layer vs. all layers we might plot.  \n\nHowever, we really want three groups right?  To do that we need a little\ntrick to combine the two variables into a new one.  Ideas how to easily make\na new variable that is a combination of two existing variables?  Take a moment\nto think about a way before continuing.\n\n`<btn type=\"button\" class=\"btn progress-continue\">Continue</btn>`{=html}\n\nOne way is to use `paste()`{.r} to combine the two variables and create a `factor`{.r}\n\n\n::: {.cell}\n```{webr}\n(onhlong$group <- factor(with(onhlong, paste(case, clinhypo, sep = \"-\"))))\n```\n:::\n\n\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) + \n  geom_point(aes(color = group))\n```\n:::\n\n\n#### Regression Lines\n\nGood start!  Now let's add a regression line with a 95% *confidence* limit\nbased on the data itself:\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) + \n    geom_point(aes(color = group)) + \n    stat_smooth(method = \"lm\", data = subset(onhlong, group == \"0-No\"))\n```\n:::\n\n\nBut remember that we wanted the 95% *prediction* interval in this case. \nTo date, `ggplot2` does not have an automatic way to create the prediction band,\nso we'll use our `onhfit`{.r} dataset.\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) +\n  geom_point(aes(color = group)) +\n  stat_smooth(method = \"lm\", data = subset(onhlong, group == \"0-No\"), se = FALSE) +\n  geom_ribbon(data = onhfit, aes(ymax = upr95, ymin = lwr95))\n```\n:::\n\n\nThe `se = FALSE`{.r} argument just draws the line without the standard error band,\nand we add a `geom_ribbon()`{.r} to add the shaded area representing the prediction \ninterval based on our `onhfit`{.r} dataset.  Note, that we specify a different\ndataset with the `data`{.r} argument, but remarkably, even though `geom_ribbon`{.r}\nrequires a `x` aesthetic it can use the one we specified in our original\n`ggplot`{.r} command.\n\nBut... we have a problem that demostrates a key feature of `ggplot2`{.r}: the order\nin which layers are added matters!  The ribbon is on top of the points and\nobscures them.  We need to add the ribbon first so it is drawn first and\nthen the points and line are drawn on top of it.  Let's switch it.\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) +\n  geom_ribbon(data = onhfit, aes(x = age, ymax = upr95, ymin = lwr95)) +\n  geom_point(aes(color = group)) +\n  stat_smooth(method = \"lm\", data = subset(onhlong, group == \"0-No\"), se = FALSE)\n```\n:::\n\n\nNow make it a little lighter by specifying an `alpha`{.r} (transparency) \naesthetic.\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) +\n  geom_ribbon(data = onhfit, aes(x = age, ymax = upr95, ymin = lwr95, alpha = 0.01)) +\n  geom_point(aes(color = group)) +\n  stat_smooth(method = \"lm\", data = subset(onhlong, group == \"0-No\"), se = FALSE) \n```\n:::\n\n\n#### Legends\n\nControl the legends with `guides()`.  Here we want to get rid of the\nlegends/guides for the color and the transparency so with the `guides`{.r} \nfunction we will set them to `\"none\"`{.r}.\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) +\n  geom_ribbon(data = onhfit, aes(x = age, ymax = upr95, ymin = lwr95, alpha = 0.01)) +\n  geom_point(aes(color = group)) +\n  stat_smooth(method = \"lm\", data = subset(onhlong, group == \"0-No\"), se = FALSE) +\n  # just get rid of them for now; use the term that created the legend to get rid of it\n  guides(color = \"none\", alpha = \"none\")\n```\n:::\n\n\n\n#### Axes\n\nControl the axes with `scale_...` functions. They are named in a consistent way\n`scale_<aesthetic>_<type>` where `<aesthetic>` is the aesthetic you are controlling\nand `<type>` is the type of variable (e.g., continuous vs. discrete).  \n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) + \n  geom_ribbon(data = onhfit, aes(x = age, ymax = upr95, ymin = lwr95, alpha = 0.01)) +\n  geom_point(aes(color = group)) +\n  stat_smooth(method = \"lm\", data = subset(onhlong, group == \"0-No\"), se = FALSE) +\n  scale_y_continuous(name = \"Mean optic nerve size, mm\") + \n  guides(color = \"none\", alpha = \"none\") \n```\n:::\n\n\nNow, the same for the x-axis and add back the color legend only changing the labels of the color \"axis\":\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) +\n  geom_ribbon(data = onhfit, aes(x = age, ymax = upr95, ymin = lwr95, alpha = 0.01)) +\n  geom_point(aes(color = group)) +\n  stat_smooth(method = \"lm\", data = subset(onhlong, group == \"0-No\"), se = FALSE) +\n  scale_x_continuous(name = \"Age, years\") +\n  scale_y_continuous(name = \"Mean optic nerve size, mm\") +     \n  scale_color_discrete(labels = c(\"Control\", \"Case, Non-ONH eye\", \"Case, ONH eye\")) + \n  guides(color = guide_legend(aes(title = \"Eye type\")), alpha = \"none\") \n```\n:::\n\n\n#### Themes\n\nMake it look \"cleaner\" overall for publications, etc., by applying a theme:\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) +\n  geom_ribbon(data = onhfit, aes(x = age, ymax = upr95, ymin = lwr95, alpha = 0.01)) +\n  geom_point(aes(color = group)) +\n  stat_smooth(method = \"lm\", data = subset(onhlong, group == \"0-No\"), se = FALSE) +\n  scale_x_continuous(name = \"Age, years\") +\n  scale_y_continuous(name = \"Mean optic nerve size, mm\") +     \n  scale_color_discrete(labels = c(\"Control\", \"Case, Non-ONH eye\", \"Case, ONH eye\")) + \n  guides(color = guide_legend(aes(title = \"Eye type\")), alpha = \"none\") +\n  theme_bw()\n```\n:::\n\n\n\n#### Pure exploration\n\n`ggplot2`{.r} is great for exploration too.  For example, let's apply a\nnon-parametric smoother to the data with a 95% confindence interval.  \nThe big green band is because there is not a lot of data in that particular\ngroup.\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) + \n    geom_point(aes(color = group)) + \n    geom_smooth(aes(color = group, fill = group))\n```\n:::\n\n\nSeparate plots, but same axis, are easy to make and help make things easier to see.\n\n\n::: {.cell}\n```{webr}\nggplot(onhlong, aes(x = age, y = mean)) + \n    geom_point(aes(color = group)) + \n    geom_smooth(aes(color = group, fill = group)) + \n    facet_grid(~ group)\n```\n:::\n\n\n\n## Experimentation\n\nThe `rop` dataset, which I've already loaded, contains data on where three\ntypes of physicians (variable `type`) thought the macula position\nwas (variables `x` and `y`) on 30 photographs (variable `picture`).  \n\n\n::: {.cell}\n```{webr}\nsummary(rop)\n```\n:::\n\n\nCan you create the following picture that uses only commands and aesthetics\nthat you used above? That is with one exception: instead of `facet_grid`{.r} you should use\n`facet_wrap`{.r} to create the multiple panels.  \n\n::: {.callout-note}\nIf you run this in R directly, you will get some warnings because there are some \nmissing data points.  I have suppressed those warnings here, and if you experimenting\nin R, you can safely ignore those.\n:::\n\n\n::: {.cell}\n```{webr}\n#| echo: false\n#| warning: false\nggplot(rop, aes(x, y, color = type)) + \n  geom_point() +\n  facet_wrap(~ picture) + \n  theme_bw()\n```\n:::\n\n\nYour turn - good luck!\n\n\n::: {.cell exercise='e0' caption='Experiment'}\n```{webr}\n#| exercise: e0\n#| warning: false\n#| caption: Experiment\n```\n:::\n\n\n::: {.solution exercise=\"e0\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e0' solution='true'}\n```{webr}\n#| exercise: e0\n#| solution: true\n#| echo: false\n#| warning: false\n```\n:::\n\nWe will discuss challenges in class!\n:::\n:::\n\n\n::: {.cell exercise='e0' check='true'}\n```{webr}\n#| exercise: e0\n#| check: true\n#| warning: false\ngradethis::grade_this({\n    user_plot <- eval(parse(text = .user_code), env = .envir_prep)\n    check_it <- function(msg = \"\", test, add_to = list(msg = \"\", test = TRUE)) {\n        msg = glue::glue(\"{add_to$msg}<br>{msg}: \", if (test) \"✅\" else \"❌\")\n        list(msg = msg, test = test && add_to$test)\n    }\n    check_plot <- function(user_plot) {\n        browser()\n        out <- list(msg = \"\", test = TRUE)\n        out <- check_it(\"Correct data used (i.e., rop)\", identical(rop, user_plot@data), out)\n        out <- check_it(\"Points are plotted\", \n            \"geom_point\" %in% names(user_plot@layers), out)\n        out <- check_it(\"And no other layers used\", \n            length(user_plot@layers) == 1, out)\n        test_mapping <- function(aesthetic, expected) {\n            q1 <- rlang::quo_squash(user_plot@mapping[[aesthetic]]) \n            q1 <- is.name(q1) && q1 == expected\n            q2 <- rlang::quo_squash(user_plot@layers$geom_point$mapping[[aesthetic]]) \n            q2 <- is.name(q2) && q2 == expected\n            if (length(q1) == 0) q1 <- FALSE\n            if (length(q2) == 0) q2 <- FALSE\n            q1 || q2\n        }\n        out <- check_it(\"Correct aesthetics used (i.e., x, y, color)\", \n            test_mapping(\"x\", \"x\") && test_mapping(\"y\", \"y\") && test_mapping(\"colour\", \"type\"), \n            out)\n        out <- check_it(\"Faceting used (i.e., facet_wrap)\", \n            inherits(user_plot@facet, \"FacetWrap\"), out)\n        out <- check_it(\"Correct faceting variable used\",\n            length(user_plot@facet$vars()) != 0 &&\n            user_plot@facet$vars() == \"picture\", \n            out)\n        out <- check_it(\"Correct theme applied\", \n            identical(user_plot@theme, ggplot2::theme_bw()), out)\n        return(out)\n    }\n    out <- check_plot(user_plot)\n    if (out$test) {\n        pass(out$msg)\n    } else {\n        fail(out$msg)\n    }\n})\n```\n:::\n\n\n## Evaluation\n\nModify the figure you created above to display only the data from the retina \nphysicians (`type == \"ret\"`) and add a regression line to each graph within \nyour figure even though it doesn't make much sense here from a scientific \nperspective.  It should look something like this, but your lines can either\nbe the same or a different color.\n\n\n::: {.cell}\n```{webr}\n#| echo: false\n#| warning: false\nggplot(subset(rop, type == \"ret\"), aes(x, y, color = type)) + \n  geom_point() + \n  stat_smooth(method=\"lm\") + \n  facet_wrap(~ picture) + \n  theme_bw()\n```\n:::\n\n\nGo for it!\n\n\n::: {.cell exercise='e1'}\n```{webr}\n#| exercise: e1\n#| warning: false\n```\n:::\n\n\n::: {.solution exercise=\"e1\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e1' solution='true'}\n```{webr}\n#| exercise: e1\n#| solution: true\n#| warning: false\n```\n:::\n\nI'm not going to provide the full solution here. But hopefully  \nfeedback from the autograder and the class resources will help you get there!\n\nBut don't forget about `subset`{.r} and be sure to use bare names of variables\n(i.e., don't quote them) for example.\n:::\n:::\n\n\n::: {.cell exercise='e1' check='true'}\n```{webr}\n#| exercise: e1\n#| check: true\n#| warning: false\ngradethis::grade_this({\n    user_plot <- eval(parse(text = .user_code), env = .envir_prep)\n    check_it <- function(msg = \"\", test, add_to = list(msg = \"\", test = TRUE)) {\n        msg = glue::glue(\"{add_to$msg}<br>{msg}: \", if (test) \"✅\" else \"❌\")\n        list(msg = msg, test = test && add_to$test)\n    }\n    check_plot <- function(user_plot) {\n        out <- list(msg = \"\", test = TRUE)\n        out <- check_it(\"Correct data used\", identical(subset(rop, type == \"ret\"), user_plot@data), out)\n        out <- check_it(\"Points are plotted\", \n            \"geom_point\" %in% names(user_plot@layers), out)\n        out <- check_it(\"Linear regression layer is added\",\n            !is.null(user_plot@layers$stat_smooth) &&\n            user_plot@layers$stat_smooth$stat_params$method == \"lm\" &&\n            user_plot@layers$stat_smooth$stat_params$se &&\n            identical(user_plot@layers$stat_smooth$stat_params$level, 0.95),\n            out)\n        out <- check_it(\"And no other layers used\", \n            length(user_plot@layers) == 2, out)\n        test_mapping <- function(aesthetic, expected) {\n            q1 <- rlang::quo_squash(user_plot@mapping[[aesthetic]]) \n            q1 <- is.name(q1) && q1 == expected\n            q2 <- rlang::quo_squash(user_plot@layers$geom_point$mapping[[aesthetic]]) \n            q2 <- is.name(q2) && q2 == expected\n            if (length(q1) == 0) q1 <- FALSE\n            if (length(q2) == 0) q2 <- FALSE\n            q1 || q2\n        }\n        out <- check_it(\"Correct aesthetics used (i.e., x, y, color)\", \n            test_mapping(\"x\", \"x\") && test_mapping(\"y\", \"y\"), \n            out)\n        out <- check_it(\"Faceting used (i.e., facet_wrap)\", \n            inherits(user_plot@facet, \"FacetWrap\"), out)\n        out <- check_it(\"Correct faceting variable used\",\n            length(user_plot@facet$vars()) != 0 &&\n            user_plot@facet$vars() == \"picture\", \n            out)\n        out <- check_it(\"Correct theme applied\", \n            identical(user_plot@theme, ggplot2::theme_bw()), out)\n        return(out)\n    }\n    out <- check_plot(user_plot)\n    if (out$test) {\n        pass(out$msg)\n    } else {\n        fail(out$msg)\n    }\n})\n```\n:::\n\n\n### Submit Your Assignment\n\n\n::: {.cell type='progress-submit'}\n```{adm}\n#| type: progress-submit\n```\n:::\n\n::: {#adm-progress-submit}\n\n::: {.cell autorun='true'}\n```{webr}\n#| autorun: true\n.progress_submit(\"10-Grammar-of-Graphics\", 1)\n```\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}