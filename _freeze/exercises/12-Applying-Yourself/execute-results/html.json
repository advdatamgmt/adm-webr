{
  "hash": "33caf38f65243dcb40a0a4901f7f58d9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Applying Yourself\"\norder: 1200\nwebr:\n  cell-options:\n    autorun: true\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\n###########################################################\n# if you edit this section note there is an `r` block below too\n.course_id <- readLines(\"_static/data/course_id.txt\")\n.assignment_ids <- dget(\"_static/data/assignment_ids.txt\")\n.canvas_link <- function(a) glue::glue(\"https://canvas.emory.edu/courses/{.course_id}/assignments/{.assignment_ids[{a}]}\")\n############################################################\n.webr_progress <- data.frame(label = character(), user_code = character(), solution_code = character(), result = logical())\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    res <- gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n    .webr_progress <<- rbind(\n      .webr_progress,\n      data.frame(\n        label = label,\n        user_code = user_code,\n        solution_code = solution_code,\n        result = res$correct\n      )\n    )\n    res\n  }\n})\n.csv_data_uri <- function(df) {\n  enc_csv <- base64enc::base64encode(\n    charToRaw(\n      paste(\n        capture.output(\n          write.csv(df)),\n          collapse = \"\\n\")\n    )\n  )\n  glue::glue(\"data:text/csv;base64,{enc_csv}\")\n}\n.save_restore_progress <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::tags$a(\n      download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n      href = .csv_data_uri(df),\n      htmltools::tags$button(\n          #onClick = \"this.classList.add('clicked');\",\n          class = \"btn progress-submit\",\n          \"Save progress\",\n          .noWS = \"outside\"\n      )\n    ),\n    htmltools::tags$label(\n      `for` = \"restore-file-input\",\n      type = \"button\",\n      id = \"restore-progress-button\",\n      class = \"btn progress-submit btn-quarto\",\n      onClick = \"restore_listener();\",\n      \"Restore progress\"\n    ),\n    htmltools::tags$input(\n      type = \"file\",\n      id = \"restore-file-input\",\n      style = \"display: none\",\n      accept = \".csv\"\n    )\n  )\n}\n.steps_to_submit <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::p(\n      htmltools::strong(\"Steps to submit:\")\n    ),\n    htmltools::tags$ol(\n        htmltools::tags$li(\n        \"Save your work to your device by clicking: \",\n        htmltools::tags$a(\n            download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n            href = .csv_data_uri(df),\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Download\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"Go to related Canvas assignment (note this will open a new tab or window and you may need to login) by clicking:\",\n        htmltools::tags$a(\n            href = .canvas_link(assignment_name),\n            target = \"_blank\",\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Open Canvas Assignment\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"On the page that just opened find and click on a button\",\n        \"that looks like this in the upper right corner:\",\n        htmltools::tags$img(\n            src = \"../_static/canvas_start_assignment.png\",\n            alt = \"Start Assignment Button\",\n            style = \"max-width: 200px; border: 1px solid black; margin-left: 1em;\"\n        )\n        ),\n        htmltools::tags$li(\n        htmltools::p(\"After you click you should see the following:\"),\n        htmltools::tags$img(\n            src = \"../_static/canvas_submission.png\",\n            alt = \"Submit Assignment Image\",\n            style = \"max-width: 400px; border: 1px solid black; margin-left: 5em;\"\n        ),\n        htmltools::p(\n            \"Either drag the file you saved in the first step or click \",\n            \"\\\"Choose a file to upload\\\" under the rocket drawing \",\n            \"to find the file.\"\n        )\n        ),\n        htmltools::tags$li(\n        \"Finally, click the \\\"Submit Assignment\\\" button.\"\n        )\n    )\n  )\n}\n.progress_submit <- function(assignment_name, n_exercises, progress_obj = .webr_progress) {\n  all <- as.character(1:n_exercises)\n  done <- gsub(\"e\", \"\", sort(unique(progress_obj$label[progress_obj$result])))\n  todo <- setdiff(all, done)\n  collapse_runs <- function(x) {\n    x <- as.integer(x)\n    out <- character()\n    for (i in seq_along(x)) {\n      if (i == 1) {\n        run_start <- run_end <- x[i]\n        next\n      }\n      if (x[i] == run_end + 1) {\n        run_end <- x[i]\n      } else {\n        if (run_start == run_end) {\n          out <- c(out, as.character(run_start))\n        } else {\n          out <- c(out, glue::glue(\"{run_start}â€“{run_end}\"))\n        }\n        run_start <- run_end <- x[i]\n      }\n    }\n    if (run_start == run_end) {\n      out <- c(out, as.character(run_start))\n    } else {\n      out <- c(out, glue::glue(\"{run_start}â€“{run_end}\"))\n    }\n    out\n  }\n  collapse_nums <- function(x) {\n    x <- collapse_runs(x)\n    if (length(x) == 1) {\n      return(x)\n    } else if (length(x) == 2) {\n      return(glue::glue(\"{x[1]} and {x[2]}\"))\n    } else {\n      return(glue::glue_collapse(x, \", \", last = \", and \"))\n    }\n  }\n  if (length(todo) > 0) {\n    htmltools::div(\n      htmltools::tags$p(\n        glue::glue(\n          \"Before you can submit you still need correctly complete exercises \",\n          collapse_nums(todo),\n          \".\"\n          ),\n          style = \"color: red; font-weight: bold;\"\n      ),\n      .save_restore_progress(assignment_name)\n    )\n  } else {\n    htmltools::div(\n      htmltools::p(\n        \"All done! You can submit now!\",\n        style = \"color: green; font-weight: bold;\"\n      ),\n    .steps_to_submit(assignment_name)\n    )\n  }\n}\n```\n:::\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Exposition\n\n\n::: {.cell autorun='true'}\n```{webr}\n#| autorun: true\n#| echo: false\nload(\"_static/data/photoqual.rda\")\n```\n:::\n\n\n\n### The `apply` family\n\nR has a group of functions that all work in a similar fashion. Each of these\nfunctions takes a function as an argument and applies that function\nto each of the elements of one of its other arguments.  \n\nThese functions can replace most `for`{.r}-loops in R, and they were faster too \nhistorically.  The model function for this family of functions is: `apply`{.r}.  \n(Shocking I know! ðŸ˜± Programmers are not that creative with names;\n nor should they be!)\n\nUsing the `apply`{.r} family functions is also more \"R-like\" than using `for`{.r}. \nThat is to say, when you think in terms of these functions you are thinking more \nlike an R programmer.  Just like different human languages have different figures \nof speech, idioms, and modes of thinking that characterize them, so do computer \nlanguages.\n\nAs we have discussed previously, R lends itself to functional types of \nprogramming idioms, one of which is called mapping. Mapping\nmeans taking a function and \"mapping\" or \"applying\"\nthat function to every sub-element of vector, list, or array.  \nSo the `apply`{.r} family is a very \"functional\" programming idiom.\n\nSo, let's get started with the `apply`{.r} function.  The `apply`{.r} function works\non the rows or columns of an `data.frame`{.r} or `array`{.r}. We have not met \nan `array`{.r} before but they are essentially a `vector`{.r} that has 2 or more \ndimensions (e.g., a table has two dimensions) of all the same **atomic** data type.  \nWe will create one that contains 10,000 coin\nflip experiments using 100 flips in each experiment.  \nThe function `rbinom`{.r} generates random binomially distributed\ndata.\n\n\n::: {.cell}\n```{webr}\nset.seed(42)\nrbinom(100, 1, 0.5)\n```\n:::\n\n\nDo the same thing 10,000 times and store the results in an array.\n\n\n::: {.cell}\n```{webr}\nexperiments <- replicate(10000, rbinom(100, 1, 0.5))\n```\n:::\n\n\nLook at the first few rows and columns and the dimensions of the array.\n\n\n::: {.cell}\n```{webr}\nexperiments[1:10, 1:10]\nNROW(experiments)\nNCOL(experiments)\ndim(experiments)\n```\n:::\n\n\nSo we have 10,000 experiments of 100 coin flips each.  Each expermient is in \none column as we can see because there are 100 rows.  If we wanted to plot a \nhistogram of how many heads were flipped (calling 1 as heads and 0 as tails) \nthen we could  use the apply function to add each column up before calling \n`hist`{.r}.  In `apply`{.r} the second argument is the margin, i.e., which\ndimension you want to apply the function over.  In this case, we want to apply\nover the columns so we use `2`{.r} as the second argument.  The third argument is the\nfunction to apply, in this case `sum`{.r}.\n\n\n::: {.cell}\n```{webr}\nheads <- apply(experiments, 2, sum)\nlength(heads)\nhist(heads)\nmean(heads)\nvar(heads)\n```\n:::\n\n\nGlad that meets our expectations for the [mean and variance of\na binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution)!\n\n### `lapply`\n\nYou probably recall from your basic statistics class that as the sample size \nincreases our confidence in the mean increases. That means that the \nstandard deviation / variance around the estimate of the mean decreases. \nLetâ€™s test that in R. We could do the following, but it is a lot of typing to do \nalmost the same thing:\n\n\n::: {.cell}\n```{webr}\nsd(replicate(1000, mean(rnorm(10,   100, 25)))) # 1000 experiments of n=10\nsd(replicate(1000, mean(rnorm(100,  100, 25)))) # 1000 experiments of n=100\nsd(replicate(1000, mean(rnorm(1000, 100, 25)))) # 1000 experiments of n=1000\n```\n:::\n\n\nWhat if we converted the second part of the experession to a function like this?\n\n::: {.cell}\n```{webr}\nrsd <- function(n) sd(replicate(1000, mean(rnorm(n, 100, 25))))\n```\n:::\n\n\nThen, we could use the `lapply`{.r} function to complete these three lines of code\nin one.  The `l`{.r} in `lapply`{.r} stands for \"list\" because it always returns \na `list`{.r}.\n\n\n::: {.cell}\n```{webr}\nlapply(c(10, 100, 1000), rsd)\n```\n:::\n\n\nNaming little utility functions like `rmean`{.r} can get annoying, so it turns\nout that in R you can just use what are called **lambda** functions, i.e.,\nunnamed functions.  So, you could do the above like this.\n\n\n::: {.cell}\n```{webr}\nlapply(c(10, 100, 1000), function(n) sd(replicate(1000, mean(rnorm(n, 100, 25)))))\n```\n:::\n\n\nThat way you do not have to name the function.  It is your call when\nyou name the function and when you use a lambda function instead.\nMost advanced programmers would do the latter in this case\nbecause it is short enough to comprehend easily, but either is absolutely\nacceptable.\n\nNow, let's return not only the variance but the mean.  Maybe here the \nfunction is complicated enough that it is worth naming separately for clarity:\n\n\n::: {.cell}\n```{webr}\nrmv <- function(n) {\n  r <- replicate(1000, mean(rnorm(n, 100, 25)))\n  list(mean = mean(r), var = var(r))\n}\nlapply(c(10, 100, 1000), rmv)\n```\n:::\n\n\nEven more compact and adding one more power of 10.\n\n::: {.cell}\n```{webr}\nlapply(10^(1:4), rmv)\n```\n:::\n\n\nThis is less error prone, requires less typing, and is much more clear\nthan cutting and pasting a lot of code.\n\n### `sapply`\n\nWhen you return a single value you can use `sapply`{.r} to return a `vector`{.r} instead\nof a `list`:\n\n::: {.cell}\n```{webr}\nsapply(10^(1:3), rsd)\n```\n:::\n\n\nor an `array`{.r} when you return more than one:\n\n::: {.cell}\n```{webr}\nsapply(10^(1:3), rmv)\n```\n:::\n\n\nThe `s`{.r} in `sapply`{.r} stands for \"simplify\".  It tries to simplify the\nresult into a `vector`{.r} or `array`{.r} if possible.  If not, it returns a `list`{.r} \nlike `lapply`{.r}.\n\n### Are you feeling ragged yet?\n\nYou will quite frequently run into datasets like the following one I've already\nloaded for you that contains information about the ocular photographs of patients,\neach with a different number of photographs:\n\n\n::: {.cell}\n```{webr}\nhead(photoqual)\n```\n:::\n\n\nIt may be tempting to run the `summary`{.r} function on the dataset, but you cannot \ndo that in this case. You would get a weighted average of age by the number of \nphotographs that the patient had taken, i.e., not the correct thing to report! \nPlus, the observations are not independent so your inferential statistics would be\nall messed up.\n\nThe `tapply`{.r} function comes to the rescue because it allows a function to be applied to a \n**ragged array**, i.e., an unbalanced or an inconsistent number of observations \nin each set/array. So, what if you wanted to count how many photographs\neach patient had on each eye?  Here's how you would do it.\n\n\n::: {.cell}\n```{webr}\ntapply(photoqual$eye, photoqual$ptid, summary)\n```\n:::\n\n\nPretty amazing, eh? I think this is even more amazing, it uses the `do.call`\nfunction which takes a function name and applies it to a list which it takes\nas its second argument.  So we can combine `do.call`{.r} with `tapply`{.r} to get a\nnice table of the summaries for each patient.\n\n\n::: {.cell}\n```{webr}\ndo.call(rbind, tapply(photoqual$eye, photoqual$ptid, summary))\n```\n:::\n\n\n`do.call`{.r} is useful when you are trying to `apply`{.r} a function like `rbind`{.r} that\ntakes `...`{.r} as an argument (like `sum`{.r}, but not like `mean`{.r} - take a look\nat the help for each of those functions).\n\nBy the way, another function called `aggregate`{.r} can do the same thing as the \n`do.call`{.r} + `tapply`{.r} combination in this case and is probably better in \nthis instance because you probably want to keep the patient identifier associated \nwith the response.\n\n\n::: {.cell}\n```{webr}\naggregate(photoqual$eye, photoqual['ptid'], function(x) summary(x))\n```\n:::\n\n\nHowever, `tapply`{.r} is a good way to capture a single variable \nfor all patients in a dataset like this.  For example, here is the \ncorrect `summary`{.r} of the age for these patients.\n\nNote that this\n\n\n::: {.cell}\n```{webr}\ntapply(photoqual$age, photoqual$ptid, function(x) head(x, 1))\n```\n:::\n\n\nis equivalent to this.\n\n\n::: {.cell}\n```{webr}\ntapply(photoqual$age, photoqual$ptid, head, 1)\n```\n:::\n\n\nNow do the summary.\n\n\n::: {.cell}\n```{webr}\nsummary(tapply(photoqual$age, photoqual$ptid, head, 1))\n```\n:::\n\n\n### You are not satisfied with just one argument?!?\n\nThere are several other `apply`{.r} family functions. Several are beyond the \nscope of this class, but as you advance in your R programming,\nI want you to know others exist and to give you a brief taste of what\nis possible with one of them. The major apply functions that we are \"skipping\"\nare: `mapply`{.r}, `rapply`{.r}, `vapply`{.r}, and `eapply`{.r}.\nI would recommend that if you want to learn more that you proceed in that\norder. Here is a taste of `mapply` which uses each of the arguments after the \nfunction in order and walks through both simultaneously similar to a previous \nexample.\n\n\n::: {.cell}\n```{webr}\nmapply(rep, 1:4, 4:1)\n```\n:::\n\n\nIs not the same as\n\n\n::: {.cell}\n```{webr}\nrep(1:4, 4:1)\n```\n:::\n\n\nbut is the same as.\n\n\n::: {.cell}\n```{webr}\nlist(\n  rep(1, 4),\n  rep(2, 3),\n  rep(3, 2),\n  rep(4, 1)\n)\n```\n:::\n\n\nUseful? You betcha! Is that obvious to you now? Probably not... but be on the \nlookout. The `apply`{.r} family can save you enormous amounts of time and can \nmake you feel like you have a magic wand for data. ðŸª„\n\n### Advanced tables\n\nNow that you know the `apply`{.r} family take another look at the\n[Advanced Table Example](09b-Advanced-Table-Example.qmd).\n\n## Evaluation\n\nUse `tapply` to determine the mean quality each patient had in each eye.  That\nis calculate the mean of the quality for the first patient's right eye, the\nfirst patient's left eye, etc.\n\nLook at the help for `tapply` and realize that you can use more than one factor\nas the `INDEX`.  Note that the help says it has to be a `list`.  How do you make\na `list` again? \n\n\n::: {.cell exercise='e1' caption='Exercise'}\n```{webr}\n#| exercise: e1\n#| caption: Exercise\ntapply(______)\n```\n:::\n\n\n::: { .solution exercise=\"e1\" }\n\n::: {.cell exercise='e1' solution='true'}\n```{webr}\n#| exercise: e1\n#| solution: true\ntapply(photoqual$quality, list(photoqual$ptid, photoqual$eye), mean)\n```\n:::\n\n:::\n\n\n::: {.cell exercise='e1' check='true'}\n```{webr}\n#| exercise: e1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n::: {.cell exercise='e1' type='open-on-pass'}\n```{adm}\n#| exercise: e1\n#| type: open-on-pass\nThink about why some values are missing in your result?\n```\n:::\n\n\n\n### Submit Your Assignment\n\n\n::: {.cell type='progress-submit'}\n```{adm}\n#| type: progress-submit\n```\n:::\n\n::: {#adm-progress-submit}\n\n::: {.cell autorun='true'}\n```{webr}\n#| autorun: true\n.progress_submit(\"12-Applying-Yourself\", 1)\n```\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}