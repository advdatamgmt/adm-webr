{
  "hash": "9e6bdb8a1db501b0990ab1f7eade73f3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Reproducible Research Exercise\"\norder: 975\npackages:\n  - litedown\n  - codetools\n  - rvest\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\n###########################################################\n# if you edit this section note there is an `r` block below too\n.course_id <- readLines(\"_static/data/course_id.txt\")\n.assignment_ids <- dget(\"_static/data/assignment_ids.txt\")\n.canvas_link <- function(a) glue::glue(\"https://canvas.emory.edu/courses/{.course_id}/assignments/{.assignment_ids[{a}]}\")\n############################################################\n.webr_progress <- data.frame(label = character(), user_code = character(), solution_code = character(), result = logical())\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    res <- gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n    .webr_progress <<- rbind(\n      .webr_progress,\n      data.frame(\n        label = label,\n        user_code = user_code,\n        solution_code = solution_code,\n        result = res$correct\n      )\n    )\n    res\n  }\n})\n.csv_data_uri <- function(df) {\n  enc_csv <- base64enc::base64encode(\n    charToRaw(\n      paste(\n        capture.output(\n          write.csv(df)),\n          collapse = \"\\n\")\n    )\n  )\n  glue::glue(\"data:text/csv;base64,{enc_csv}\")\n}\n.save_restore_progress <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::tags$a(\n      download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n      href = .csv_data_uri(df),\n      htmltools::tags$button(\n          #onClick = \"this.classList.add('clicked');\",\n          class = \"btn progress-submit\",\n          \"Save progress\",\n          .noWS = \"outside\"\n      )\n    ),\n    htmltools::tags$label(\n      `for` = \"restore-file-input\",\n      type = \"button\",\n      id = \"restore-progress-button\",\n      class = \"btn progress-submit btn-quarto\",\n      onClick = \"restore_listener();\",\n      \"Restore progress\"\n    ),\n    htmltools::tags$input(\n      type = \"file\",\n      id = \"restore-file-input\",\n      style = \"display: none\",\n      accept = \".csv\"\n    )\n  )\n}\n.steps_to_submit <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::p(\n      htmltools::strong(\"Steps to submit:\")\n    ),\n    htmltools::tags$ol(\n        htmltools::tags$li(\n        \"Save your work to your device by clicking: \",\n        htmltools::tags$a(\n            download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n            href = .csv_data_uri(df),\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Download\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"Go to related Canvas assignment (note this will open a new tab or window and you may need to login) by clicking:\",\n        htmltools::tags$a(\n            href = .canvas_link(assignment_name),\n            target = \"_blank\",\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Open Canvas Assignment\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"On the page that just opened find and click on a button\",\n        \"that looks like this in the upper right corner:\",\n        htmltools::tags$img(\n            src = \"../_static/canvas_start_assignment.png\",\n            alt = \"Start Assignment Button\",\n            style = \"max-width: 200px; border: 1px solid black; margin-left: 1em;\"\n        )\n        ),\n        htmltools::tags$li(\n        htmltools::p(\"After you click you should see the following:\"),\n        htmltools::tags$img(\n            src = \"../_static/canvas_submission.png\",\n            alt = \"Submit Assignment Image\",\n            style = \"max-width: 400px; border: 1px solid black; margin-left: 5em;\"\n        ),\n        htmltools::p(\n            \"Either drag the file you saved in the first step or click \",\n            \"\\\"Choose a file to upload\\\" under the rocket drawing \",\n            \"to find the file.\"\n        )\n        ),\n        htmltools::tags$li(\n        \"Finally, click the \\\"Submit Assignment\\\" button.\"\n        )\n    )\n  )\n}\n.progress_submit <- function(assignment_name, n_exercises, progress_obj = .webr_progress) {\n  all <- as.character(1:n_exercises)\n  done <- gsub(\"e\", \"\", sort(unique(progress_obj$label[progress_obj$result])))\n  todo <- setdiff(all, done)\n  collapse_runs <- function(x) {\n    x <- as.integer(x)\n    out <- character()\n    for (i in seq_along(x)) {\n      if (i == 1) {\n        run_start <- run_end <- x[i]\n        next\n      }\n      if (x[i] == run_end + 1) {\n        run_end <- x[i]\n      } else {\n        if (run_start == run_end) {\n          out <- c(out, as.character(run_start))\n        } else {\n          out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n        }\n        run_start <- run_end <- x[i]\n      }\n    }\n    if (run_start == run_end) {\n      out <- c(out, as.character(run_start))\n    } else {\n      out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n    }\n    out\n  }\n  collapse_nums <- function(x) {\n    x <- collapse_runs(x)\n    if (length(x) == 1) {\n      return(x)\n    } else if (length(x) == 2) {\n      return(glue::glue(\"{x[1]} and {x[2]}\"))\n    } else {\n      return(glue::glue_collapse(x, \", \", last = \", and \"))\n    }\n  }\n  if (length(todo) > 0) {\n    htmltools::div(\n      htmltools::tags$p(\n        glue::glue(\n          \"Before you can submit you still need correctly complete exercises \",\n          collapse_nums(todo),\n          \".\"\n          ),\n          style = \"color: red; font-weight: bold;\"\n      ),\n      .save_restore_progress(assignment_name)\n    )\n  } else {\n    htmltools::div(\n      htmltools::p(\n        \"All done! You can submit now!\",\n        style = \"color: green; font-weight: bold;\"\n      ),\n    .steps_to_submit(assignment_name)\n    )\n  }\n}\n```\n:::\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Evaluation\n\nThe goal is to use the built in dataset `mtcars` to produce a an HTML \ntable in a reproducible research Quarto document. The table should show the mean and\nstandard deviation of the average miles per gallon (`mpg`) and vehicle weight (`wt`) \nfor each number of cylinders (`cyl`) in the dataset.  The mean should be formatted\nto one decimal place and the standard deviation to two decimal places and the\nstandard deviation should be shown in parentheses next to the mean.\n\nMake sure that it is self-contained by setting the YAML options correctly and at \na mininmum include a title and an author in the YAML header.\n\nIf you've done it correctly your output should look something like this.\n\n\n```{=html}\n<iframe src=\"/_static/qmd_render/exercise.html\" \nstyle=\"width:100%; height:450px; border: 2px solid black;\"></iframe>\n```\n\nIt is absolutely ok if your title, author, column names, etc. are different \nthan the ones shown here as long as the necessary elements are there and\nthe body of the table is the same. It is also ok if you show your R\ncode, but I did not for, I hope, obvious reasons 😉.\n\nOn your own, also make sure you can create an HTML file in RStudio \n(or your IDE of choice) and that you can find and open that file in the web \nbrowser on your computer.  Maybe e-mail it to yourself to prove it is \ncompletely self-contained.\n\nNow it's your turn!\n\n::: {.callout-caution}\n### Limited Quarto support\n\nQuarto support in browser is not yet available so I have only mocked some parts\nof it for this exercise.  Don't try anything too fancy here and expect it to \nwork!\n:::\n\n\n::: {.cell exercise='e1' setup='true'}\n```{webr}\n#| exercise: e1\n#| setup: true\nlibrary(codetools)\nlibrary(rvest)\nfix_author <- function(x) {\n    sub(\n        \"author:[[:blank:]]*(.+)$\",\n        \"author: <div class=\\\"quarto-title-meta\\\"><div><div class=\\\"quarto-title-meta-heading\\\">Author</div><div class=\\\"quarto-title-meta-contents\\\"><p>\\\\1</p></div></div></div>\",\n        x,\n        perl = TRUE\n    )\n}\n\ncheck_it <- function(msg = \"\", test, add_to = list(msg = \"\", test = TRUE)) {\n    msg = glue::glue(\"{add_to$msg}<br>{msg}: \", if (test) \"✅\" else \"❌\")\n    list(msg = msg, test = test && add_to$test)\n}\n\nmock_quarto <- function(x, html = TRUE) {\n    lines <- strsplit(x, \"\\n\")[[1]]\n    lines <- sapply(lines, fix_author)\n    x <- paste(lines, collapse = \"\\n\")\n\n    out <- list(msg = \"\", test = TRUE)\n\n    yaml_edge <- grep(\"---\", lines)\n    if (length(yaml_edge) < 2) {\n        stop(\"Can't find YAML header starting & ending with '---'\")\n        found_yaml <- FALSE\n    } else {\n        found_yaml <- TRUE\n    }\n    yaml_lines <- paste(\n        lines[(yaml_edge[1] + 1):(yaml_edge[2] - 1)],\n        sep = \"\\n\"\n    )\n\n    out <- check_it(\"Found YAML header\", found_yaml, out)\n\n    meta <- yaml::yaml.load(yaml_lines)\n\n    out <- check_it(\n        \"-- HTML format detected\",\n        \"html\" %in% names(meta$format) || meta$format == \"html\",\n        out\n    )\n\n    run_it <- out$test # later don't run if not HTML format\n\n    if (\"html\" %in% names(meta$format)) {\n        out <- check_it(\n            \"-- Embedding resources requested\",\n            \"embed-resources\" %in%\n                names(meta$format$html) &&\n                meta$format$html$`embed-resources`,\n            out\n        )\n    } else {\n        out <- check_it(\"-- Embedding resources requested\", FALSE, out)\n    }\n\n    out <- check_it(\"-- Title detected\", \"title\" %in% names(meta), out)\n    out <- check_it(\"-- Author detected\", \"author\" %in% names(meta), out)\n\n    if (run_it) {\n        rendered <- litedown::mark(\n            litedown::fuse(\n                x,\n                \".md\"\n            ),\n            meta = list(\n                `header-includes` = '<style type=\"text/css\">\n                    .frontmatter { text-align: left; }\n                    .author { \n                        text-transform: uppercase;\n                        margin-top: 1em;\n                        font-size: .9em;\n                        opacity: .8;\n                        font-weight: 400; \n                    }\n                    .quarto-title-meta p {\n                        margin: 0;\n                        padding: 0;\n                    }\n                    .frontmatter .author h2 {\n                        font-size: unset;\n                        font-weight: unset;\n                    }\n                </style>'\n            )\n        )\n        html_tables <- rvest::read_html(rendered) |>\n            rvest::html_elements(\"table\")\n\n        test_df <- data.frame(\n            a = c(4, 6, 8),\n            b = c(\"26.7\", \"19.7\", \"15.1\"),\n            c = c(\"(4.51)\", \"(1.45)\", \"(2.56)\"),\n            d = c(\"2.3\", \"3.1\", \"4.0\"),\n            e = c(\"(0.57)\", \"(0.36)\", \"(0.76)\")\n        )\n\n        dfs <- lapply(html_tables, rvest::html_table, convert = FALSE)\n\n        tbl_out <- list(msg = \"<br>\", test = TRUE)\n\n        for (df in seq_along(dfs)) {\n            tbl_out$test <- TRUE\n            tbl_out <- check_it(\n                glue::glue(\"---- Table {df} of {length(dfs)} has 5 columns\"),\n                NCOL(dfs[[df]]) == 5,\n                tbl_out\n            )\n            if (!tbl_out$test) {\n                next\n            }\n            for (col in seq_along(dfs[[df]])) {\n                tbl_out <- check_it(\n                    glue::glue(\n                        \"------ Column {col} matches expected\"\n                    ),\n                    identical(\n                        as.character(as.data.frame(dfs[[df]])[, col]),\n                        as.character(test_df[, col])\n                    ),\n                    tbl_out\n                )\n                if (!tbl_out$test) break\n            }\n            if (tbl_out$test) break\n        }\n    } else {\n        tbl_out <- list(msg = \"<br>\", test = FALSE)\n        out <- check_it(\n            \"-- Table not checked because not HTML format\",\n            FALSE,\n            out\n        )\n        rendered <- \"<p>Not rendered (not HTML format)</p>\"\n    }\n\n    if (html) {\n        htmltools::HTML(glue::glue(\n            '<iframe style=\"width:100%; margin-bottom: 1em; padding: 1em; min-height: 350px; border: 2px solid black;\"src=\"data:text/html;charset=utf-8;base64,{base64enc::base64encode(charToRaw(rendered))}\"></iframe>'\n        ))\n    } else {\n        out$msg <- paste0(out$msg, tbl_out$msg)\n        out$test <- out$test && tbl_out$test\n        return(out)\n    }\n}\n\n```\n:::\n\n\n\n::: {.cell data-caption=\"Exercise\" data-exercise=\"e1\"}\n```{ojs}\n//| echo: false\nviewof _webr_editor_quarto_exercise = {\n  const { WebRExerciseEditor, b64Decode } = window._exercise_ojs_runtime;\n\n  // Default exercise configuration\n  const options = {\n      exercise: \"e1\",\n      id: \"webr-e1-contents\",\n      envir: `exercise-env-e1`,\n      error: false,\n      caption: 'Exercise',\n  }\n\n  const editor = new WebRExerciseEditor(webROjs.webRPromise, \"---\\nformat: html\\n---\\n\\n```{r}\\n\\n```\", options);\n\n  editor.onInput = (ev) => {\n    // When using run button, prevent firing of reactive ojs updates until `manual: true`.\n    if (editor.options.runbutton && !ev.detail.commit) {\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n      return;\n    }\n\n    // Update reactive value for code contents\n    editor.container.value.code = editor.view.state.doc.toString();\n    if ('code' in ev.detail) {\n      editor.container.value.code = ev.detail.code;\n    }\n    editor.container.value.code = \"mock_quarto('\".concat(editor.container.value.code.replace(/'/g, \"\\\\'\"), \"')\");\n\n    // Store latest updates to editor content to local browser storage\n    if (editor.options.persist) {\n      window.localStorage.setItem(editor.storageKey, editor.container.value.code);\n    }\n  }\n  return editor.container;\n}\nviewof _webr_value_quarto_exercise = webROjs.process(_webr_editor_quarto_exercise, \"\");\n_webr_feedback_quarto_exercise = {\n  const { WebRGrader, Indicator } = window._exercise_ojs_runtime;\n  const { isRNull, isRList } = window._exercise_ojs_runtime.WebR;\n  const emptyFeedback = document.createElement('div');\n\n  const grader = new WebRGrader(_webr_value_quarto_exercise.evaluator);\n\n  grader.gradeExercise = async function() {\n\n    const user_code = grader.context.code;\n\n    // If there's no code to be evaluated yet, return blank feedback\n    if (!user_code) {\n      return null;\n    }\n  \n    // Check for a parse error before evaluating user code\n    let checkResult = await grader.parseCheck(user_code);\n    if (!isRNull(checkResult)) {\n      return await grader.feedbackAsHtmlAlert(checkResult);\n    }\n\n    // Evaluate user code and check with provided `check`\n    let ind = grader.context.indicator;\n    if (!grader.context.indicator) {\n      ind = new Indicator();\n    }\n    ind.running();\n\n    try {\n      checkResult = await grader.evaluateExercise();\n      if (isRNull(checkResult)) {\n        return null;\n      }\n      const container = await grader.evaluator.asHtml(checkResult, grader.options);\n      const result = await container.value.result;\n      const classList = await (await result.class()).toArray();\n\n      // Is this a feedback from gradethis\n      if (classList.includes(\"gradethis_graded\") || classList.includes(\"gradethis_feedback\")) {\n        return await grader.feedbackAsHtmlAlert(result);\n      }\n\n      // This is feedback contained in an R list object\n      if (isRList(result)) {\n        const message = await result.get(\"message\");\n        const correct = await result.get(\"correct\");\n        if (!isRNull(message) && !isRNull(correct)) {\n          return await grader.feedbackAsHtmlAlert(result);\n        }\n      }\n\n      return container;\n    } finally {\n      ind.finished();\n      if (!grader.context.indicator) ind.destroy();\n    }\n  }\n\n  const feedback = await grader.gradeExercise();\n  if (!feedback) return emptyFeedback; \n  return feedback;\n}\n```\n:::\n\n::: {.solution exercise=\"e1\"}\n::: {.callout-note collapse=\"false\"}\n\n::: {.cell exercise='e1' solution='true'}\n```{webr}\n#| exercise: e1\n#| solution: true\n#| echo: false\n```\n:::\n\nI'm not going to provide the full solution here. But hopefully feedback from the autograder and the class resources will help you get there!\n:::\n:::\n\n\n::: {.cell exercise='e1' check='true'}\n```{webr}\n#| exercise: e1\n#| check: true\ngradethis::grade_this({\n  res <- mock_quarto(.user_code, html = FALSE)\n  if(res$test) {\n    pass(res$msg)\n  } else {\n    fail(res$msg)\n  }\n})\n```\n:::\n\n\n\n### Submit Your Assignment\n\n\n::: {.cell type='progress-submit'}\n```{adm}\n#| type: progress-submit\n```\n:::\n\n::: {#adm-progress-submit}\n\n::: {.cell autorun='true'}\n```{webr}\n#| autorun: true\n.progress_submit(\"09-Reproducible-Research\", 1)\n```\n:::\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}