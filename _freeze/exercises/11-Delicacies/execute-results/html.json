{
  "hash": "109b0879d24aff38406b74d60fe97046",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Delicacies: Missing Data, Text, and Dates\"\norder: 1100\nwebr:\n  packages:\n    - lubridate\n  cell-options:\n    autorun: true\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\n###########################################################\n# if you edit this section note there is an `r` block below too\n.course_id <- readLines(\"_static/data/course_id.txt\")\n.assignment_ids <- dget(\"_static/data/assignment_ids.txt\")\n.canvas_link <- function(a) glue::glue(\"https://canvas.emory.edu/courses/{.course_id}/assignments/{.assignment_ids[{a}]}\")\n############################################################\n.webr_progress <- data.frame(label = character(), user_code = character(), solution_code = character(), result = logical())\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    res <- gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n    .webr_progress <<- rbind(\n      .webr_progress,\n      data.frame(\n        label = label,\n        user_code = user_code,\n        solution_code = solution_code,\n        result = res$correct\n      )\n    )\n    res\n  }\n})\n.csv_data_uri <- function(df) {\n  enc_csv <- base64enc::base64encode(\n    charToRaw(\n      paste(\n        capture.output(\n          write.csv(df)),\n          collapse = \"\\n\")\n    )\n  )\n  glue::glue(\"data:text/csv;base64,{enc_csv}\")\n}\n.save_restore_progress <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::tags$a(\n      download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n      href = .csv_data_uri(df),\n      htmltools::tags$button(\n          #onClick = \"this.classList.add('clicked');\",\n          class = \"btn progress-submit\",\n          \"Save progress\",\n          .noWS = \"outside\"\n      )\n    ),\n    htmltools::tags$label(\n      `for` = \"restore-file-input\",\n      type = \"button\",\n      id = \"restore-progress-button\",\n      class = \"btn progress-submit btn-quarto\",\n      onClick = \"restore_listener();\",\n      \"Restore progress\"\n    ),\n    htmltools::tags$input(\n      type = \"file\",\n      id = \"restore-file-input\",\n      style = \"display: none\",\n      accept = \".csv\"\n    )\n  )\n}\n.steps_to_submit <- function(assignment_name, df = .webr_progress) {\n  now <- strftime(Sys.time(), \"%Y%m%d-%H%M%S\")\n  htmltools::div(\n    htmltools::p(\n      htmltools::strong(\"Steps to submit:\")\n    ),\n    htmltools::tags$ol(\n        htmltools::tags$li(\n        \"Save your work to your device by clicking: \",\n        htmltools::tags$a(\n            download = glue::glue('adm-{.assignment_ids[assignment_name]}-{now}.csv'),\n            href = .csv_data_uri(df),\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Download\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"Go to related Canvas assignment (note this will open a new tab or window and you may need to login) by clicking:\",\n        htmltools::tags$a(\n            href = .canvas_link(assignment_name),\n            target = \"_blank\",\n            htmltools::tags$button(\n                onClick = \"this.classList.add('clicked');\",\n                class=\"progress-submit\",\n                \"Open Canvas Assignment\"\n            )\n        )\n        ),\n        htmltools::tags$li(\n        \"On the page that just opened find and click on a button\",\n        \"that looks like this in the upper right corner:\",\n        htmltools::tags$img(\n            src = \"../_static/canvas_start_assignment.png\",\n            alt = \"Start Assignment Button\",\n            style = \"max-width: 200px; border: 1px solid black; margin-left: 1em;\"\n        )\n        ),\n        htmltools::tags$li(\n        htmltools::p(\"After you click you should see the following:\"),\n        htmltools::tags$img(\n            src = \"../_static/canvas_submission.png\",\n            alt = \"Submit Assignment Image\",\n            style = \"max-width: 400px; border: 1px solid black; margin-left: 5em;\"\n        ),\n        htmltools::p(\n            \"Either drag the file you saved in the first step or click \",\n            \"\\\"Choose a file to upload\\\" under the rocket drawing \",\n            \"to find the file.\"\n        )\n        ),\n        htmltools::tags$li(\n        \"Finally, click the \\\"Submit Assignment\\\" button.\"\n        )\n    )\n  )\n}\n.progress_submit <- function(assignment_name, n_exercises, progress_obj = .webr_progress) {\n  all <- as.character(1:n_exercises)\n  done <- gsub(\"e\", \"\", sort(unique(progress_obj$label[progress_obj$result])))\n  todo <- setdiff(all, done)\n  collapse_runs <- function(x) {\n    x <- as.integer(x)\n    out <- character()\n    for (i in seq_along(x)) {\n      if (i == 1) {\n        run_start <- run_end <- x[i]\n        next\n      }\n      if (x[i] == run_end + 1) {\n        run_end <- x[i]\n      } else {\n        if (run_start == run_end) {\n          out <- c(out, as.character(run_start))\n        } else {\n          out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n        }\n        run_start <- run_end <- x[i]\n      }\n    }\n    if (run_start == run_end) {\n      out <- c(out, as.character(run_start))\n    } else {\n      out <- c(out, glue::glue(\"{run_start}–{run_end}\"))\n    }\n    out\n  }\n  collapse_nums <- function(x) {\n    x <- collapse_runs(x)\n    if (length(x) == 1) {\n      return(x)\n    } else if (length(x) == 2) {\n      return(glue::glue(\"{x[1]} and {x[2]}\"))\n    } else {\n      return(glue::glue_collapse(x, \", \", last = \", and \"))\n    }\n  }\n  if (length(todo) > 0) {\n    htmltools::div(\n      htmltools::tags$p(\n        glue::glue(\n          \"Before you can submit you still need correctly complete exercises \",\n          collapse_nums(todo),\n          \".\"\n          ),\n          style = \"color: red; font-weight: bold;\"\n      ),\n      .save_restore_progress(assignment_name)\n    )\n  } else {\n    htmltools::div(\n      htmltools::p(\n        \"All done! You can submit now!\",\n        style = \"color: green; font-weight: bold;\"\n      ),\n    .steps_to_submit(assignment_name)\n    )\n  }\n}\n```\n:::\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Exposition\n\n### Missing data\n\nWe've already seen the missing data value: `NA`.  This special value allows R to \nhandle missing data gracefully.  However, just like in other programming languages \nyou sometimes have to be careful how you handle `NA`.\n\n\n::: {.cell}\n```{webr}\nNA\n```\n:::\n\n\nWhy `is.na`{.r} vs. `is.NA`{.r}?  Not the ideal naming convention, \nbut that's what it is.\n\n\n::: {.cell}\n```{webr}\nis.na(NA) \nis.na(2)\nmyvec <- c(1, 2, NA, 3)\nis.na(myvec)\n```\n:::\n\n\nNow, let's try to take the mean of `myvec`{.r}.\n\n\n::: {.cell}\n```{webr}\nmean(myvec)\n```\n:::\n\n\nWhat happened?  Why is mean of `myvec`{.r} `NA`{.r}?  By default, the `mean`{.r} \nfunction does this intentionally so that you know that the `vector`{.r} is missing \ndata because what you want to do is unclear.  Under most circumstances you just want \nto remove the missing values and calculate the mean on the values you have, \nlike this:\n\n\n::: {.cell}\n```{webr}\nmean(myvec, na.rm = TRUE)\n```\n:::\n\n\nThis is also important when dealing with `data.frame`{.r}'s.  \nLet's inject some missing data into `esoph`{.r}.\n\n\n::: {.cell}\n```{webr}\nset.seed(596)\nesona <- esoph\nesona[sample(NROW(esona), 3), \"ncases\"] <- NA\nesona[sample(NROW(esona), 3), \"ncontrols\"] <- NA\nsummary(esona)\n```\n:::\n\n\nNote now three `NA`{.r}'s are tabulated by the `summary`{.r} function and\nthese are ignored in the summary statistics.   However, if you try to take the \nmean of the `ncases`{.r} column without specifying `na.rm`{.r} you'll get `NA`{.r} again...\n\n\n::: {.cell}\n```{webr}\nmean(esona$ncases)\n```\n:::\n\n\n*vs.*\n\n\n::: {.cell}\n```{webr}\nmean(esona$ncases, na.rm = TRUE)\n```\n:::\n\n\nYou may be interested in which cases/rows are complete and the number of complete \nand incomplete cases/rows:\n\n\n::: {.cell}\n```{webr}\ncomplete.cases(esona)\nsum(complete.cases(esona))\nsum(!complete.cases(esona))\n```\n:::\n\n\nYou can also extract the `data.frame`{.r} where every row has complete data \n(i.e., the complete cases):\n\n::: {.cell}\n```{webr}\nesocc <- na.omit(esona)\nNROW(esocc)\n```\n:::\n\n\nWhen you have missing data and you are subsetting you have to be more careful.  \nLet's look at the following to see why.\n\n\n::: {.cell}\n```{webr}\nesona$ncases == 2\n```\n:::\n\n\nSee the `NA`{.r}'s in there?  So, when you select those rows using the techniques in \nthe [\"Food Prep\"](07-Food-Prep.qmd) module there is some serious weirdness.\n\n\n::: {.cell}\n```{webr}\nesona[esona$ncases == 2, ]\n```\n:::\n\n\nWhy? Consider these examples.\n\nTake a selection containing an `NA`{.r} from a vector.\n\n\n::: {.cell}\n```{webr}\nx <- c(\"a\", \"b\", \"c\")\nx[c(NA, 2, 1)]\n```\n:::\n\n\nNow, try the same with a `data.frame`{.r}.\n\n\n::: {.cell}\n```{webr}\nesona[c(NA, 2, 1), ]\n```\n:::\n\n\nSo, when R finds an `NA`{.r} in a vector to be used as a slice, it returns a empty \nversion.  For, a `data.frame`{.r} that means an empty row.  How do we work around that?  \nIncorporate an`is.NA`{.r} test:\n\n\n::: {.cell}\n```{webr}\nesona[esona$ncases == 2 & !is.na(esona$ncases),]\n```\n:::\n\n\nThat works because anything that is `NA`{.r} will be set to `FALSE`{.r} instead of `NA`{.r}\nand not included in the selection. The `subset`{.r} function does not have this issue, \nbut remember you cannot assign directly to a `subset`{.r} so you'll need the above\nsyntax sometimes.\n\n\n::: {.cell}\n```{webr}\nsubset(esona, ncases == 2)\n```\n:::\n\n\nWhy? Look at the way `subset`{.r} works.\n\n\n::: {.cell}\n```{webr}\nsubset\n```\n:::\n\n\nOh - one of those generic functions. How about `subset.default`{.r}?\n\n\n::: {.cell}\n```{webr}\nsubset.default\n```\n:::\n\n\nLook at that line! `x[subset & !is.na(subset)]`{.r} - it handles the `NA`{.r}'s for you \nautomatically in the very way we have to do it ourselves when subsetting\nmanually!\n\n### Other special values\n\nYou met a lot of these in the very [first module](01-Rithmatic.qmd) on R basics, \nbut let's review them here.\n\n\n::: {.cell}\n```{webr}\n5/0\n-5/0\n0/0\n```\n:::\n\n\n`NaN`{.r} means \"not a number\", `Inf`{.r} means \"positive infinity\", and `-Inf`{.r} means \n\"negative infinity\".  They are almost always seen because you are dividing by zero, \nusually unintentionally.  You can test for these values like this\nwhich can help you find bugs in your programs.\n\n\n::: {.cell}\n```{webr}\nis.nan(0/0)\nis.infinite(1/0)\nis.finite(1/0)\n```\n:::\n\n\nFinally, `NULL`{.r} is a marker for \"nothing.\"  Not nothing as in something that \nought to be there but is not (i.e., missing), but literally, something that does \nnot or should not exist in the realm of R.  Sometimes it is a good way to remove \na column from a `data.frame`{.r}.  Just set it to `NULL`{.r}.\n\n\n::: {.cell}\n```{webr}\nesocc$ncases <- NULL\nhead(esocc)\n```\n:::\n\n\n### Other useful set and subsetting functions\n\nThe function `duplicated`{.r} finds duplicated values and also duplicated rows in\n`data.frames`{.r}.  The `unique`{.r} function will extract the values that are, well, \nunique!\n\n\n::: {.cell}\n```{webr}\nx <- c(4, 8, 0, 1, 8, 9, 10, 4, 2)\nduplicated(x)\nunique(x)\n```\n:::\n\n\nThe following functions allow you to make selections based on \"set\" operations.\n`union`{.r} joins two things together (without duplication), `intersection`{.r} finds\nthe common values between two vectors, and `setdiff`{.r} finds the difference\nbetween two vectors.\n\n\n::: {.cell}\n```{webr}\nunion(c(\"a\", \"b\", \"c\"), c(\"b\", \"c\", \"d\", \"f\"))\nintersect(c(\"a\", \"b\", \"c\"), c(\"b\", \"c\", \"d\"))\nsetdiff(c(1, 2, 3, 8, 9), c(2, 8))\n```\n:::\n\n\nThese can be be remarkably useful when working with certain types of \ndata or finding differences between data sets.\n\n### Text\n\n#### Pasting\n\nWe have seen `paste0`{.r} (cf. [Food Prep](07-Food-Prep.qmd)) which pastes a series \nof strings together without any other \ncharacter between.\n\n\n::: {.cell}\n```{webr}\npaste0(c(\"a\", \"b\", \"c\", \"d\"), 1, c(1, 2))\n```\n:::\n\n\nThe more general function is `paste`{.r} that takes two arguments, \n\n1. `sep`{.r} which is the separator between the elements, and  \n2. `collapse`{.r} which when set pastes the entire sequence of strings together \n   using that text.\n\n\n::: {.cell}\n```{webr}\npaste(c(\"a\", \"b\", \"c\"), 1, c(1, 2), sep = \" \")\npaste(c(\"a\", \"b\", \"c\"), 1, c(1, 2), sep = \" \", collapse = \"-\")\n```\n:::\n\n\n#### Substrings\n\nSometimes you need to select out a piece of a string by position.  The `substr`{.r} \nfunction is helpful for fixed length strings.  Note that the `[1:3]`{.r} selects out \nthe first three elements of the names of esoph while the other 1 and 3 tell it to\ntake the first through the third of each string.  The two are **not** related.\n\n\n::: {.cell}\n```{webr}\nnames(esoph)[1:3]\nsubstr(names(esoph)[1:3], 1, 3)\n```\n:::\n\n\n\n#### Regular expressions / Searching\n\n*Regular expressions* are a very powerful way of finding patterns in text and\nmanipulating them.  You could take an entire course on *regular expressions*[^1]\nso I will only be able to introduce you to some basic aspects.  They are a \nlanguage unto themselves to the extent that a humorous quote often\nstated about them is:\n\n> Some people, when confronted with a problem, think\n> “I know, I'll use regular expressions.”\n> Now they have two problems.\n--- Jamie Zawinski[^2]\n\n[^1]: A great online resource for learning more about regular expressions is [RexEgg](https://www.rexegg.com/).\n[^2]: [Source of the famous “Now you have two problems” quote](https://regex.info/blog/2006-09-15/247)\n\nStart with a list of words.\n\n\n::: {.cell}\n```{webr}\nwords <- c(\"art\", \"bat\", \"bet\", \"bee\", \"bees\", \"beet\", \"believe\", \"beat\", \n           \"cat\", \"car\", \"cars\", \"can\", \"cart\", \"mississipi\",\n           \"mart\", \"part\", \"see\", \"sat\", \"set\")\n```\n:::\n\n\nWe will use the `grep`{.r} function which takes a *regular expression* and \ncharacter vector to search on.  If you just use a character string\nwith specific patterns of letters or numbers\nyou will find strings that match that pattern of letters and numbers:\n\nThe indexes of the matches in `words`{.r}.\n\n\n::: {.cell}\n```{webr}\ngrep(\"s\", words)\n```\n:::\n\n\n\n::: {.cell}\n```{webr}\ngrep(\"s\", words, value = TRUE)\n```\n:::\n\n\nNote how each contains an \"s\".  \n\nAnother example:\n\n\n::: {.cell}\n```{webr}\ngrep(\"ee\", words, value = TRUE)\n```\n:::\n\n\nNothing ground breaking there... however some characters have special\nmeanings, e.g., `.`{.r} that will match any character.  To find words that have\nan \"a\" followed by any character:\n\n\n::: {.cell}\n```{webr}\ngrep(\"a.\", words, value = TRUE)\n```\n:::\n\n\nOr...\n\n\n::: {.cell}\n```{webr}\ngrep(\"s.t\", words, value = TRUE)\n```\n:::\n\n\nYou can put a group of characters in square brackets, e.g., `[bs]`{.r} to match \neither \"b\" or \"s\":\n\n\n::: {.cell}\n```{webr}\ngrep(\"[bs].t\", words, value = TRUE)\n```\n:::\n\n\nThe `*` character matches zero or more characters matching the previous expression\n(character or group):\n\n::: {.cell}\n```{webr}\ngrep(\"beliea*ve\", words, value = TRUE) \n```\n:::\n\n\nThe `+` character matches one or more of the previous expression:\n\n::: {.cell}\n```{webr}\ngrep(\"beliea+ve\", words, value = TRUE) # nothing matches\ngrep(\"be+t\", words, value = TRUE)\n```\n:::\n\n\nFinally you can group things in parentheses:\n\n::: {.cell}\n```{webr}\ngrep(\"m(iss)+ipi\", words, value = TRUE)\n```\n:::\n\n\nI find regular expressions to be very helpful for selecting a series of variable\nnames in a `data.frame`.\n\n\n::: {.cell}\n```{webr}\ngrep(\"gp\", names(esoph), value = TRUE)\nhead(esoph[, grep(\"gp\", names(esoph), value = TRUE)])\n```\n:::\n\n\nThe `grepl` function is also useful as it gives the `logical` vector of whether\na match is found in a sequence and may be useful in some settings where the index\nor value will not work.\n\n\n::: {.cell}\n```{webr}\ngrepl(\"gp\", names(esoph))\n```\n:::\n\n\nThere is so much more you could learn about this, but even this basic introduction\ncan take you very far.  \n\nPlease note that you can use regular expressions to select out parts of text,\nrearrange, or manipulate various strings.  See the `sub`{.r} and `gsub`{.r} \nfunctions for more information.\n\n\n### Dates\n\nDates are often difficult to work with in any programming language \nbecause there are many different formats and methods of converting\nto a system that the computer can work with.\n\nIn R, the default date format is `YYYY-MM-DD`{.r}, i.e., 4 digit year, hyphen, \n1–2 digit month, hyphen, and 1–2 digit day. The as.Date() function allows you to \ntake character strings and convert them to dates\nthat the computer can understand.\n\n\n::: {.cell}\n```{webr}\nas.Date(\"2011-01-12\")\n```\n:::\n\n\nYou can also use other formats if you receive data from someone who typed it in \ndifferently by providing a `format`{.r} argument.\n\n\n::: {.cell}\n```{webr}\nas.Date(\"01/12/2011\", format=\"%m/%d/%Y\")\nas.Date(\"12jan2011\", \"%d%b%Y\")\n```\n:::\n\n\nFor more information on formats, read the help file for `strptime`{.r}. \n\nThe `difftime` function allows you calculate various intervals\nbetween dates.\n\n\n::: {.cell}\n```{webr}\ndifftime(as.Date(\"2011-1-14\"),as.Date(\"2011-1-12\"))\ndifftime(as.Date(\"2011-1-14\"),as.Date(\"2011-1-12\"),units=\"hours\")\n```\n:::\n\n\n\nHowever, this is one case where I recommend you avoid base R from the get go\nand instead use the `lubridate`{.r} package.  The `lubridate`{.r} package\nis some of the most magical code I've seen in any language and makes\nworking with dates a breeze.  You can install it from CRAN if you don't have it already.\n\n\n::: {.cell}\n```{webr}\n#| eval: false\ninstall.packages(\"lubridate\")\n```\n:::\n\n\nOnce you have it installed, load it like any other package.\n\n\n::: {.cell}\n```{webr}\nlibrary(lubridate)\n```\n:::\n\n\nNow, you can use functions like `ymd`{.r}, `mdy`{.r}, and `dmy`{.r} to convert\ncharacter strings to dates without having to worry about format strings.\n\n\n::: {.cell}\n```{webr}\nymd(\"2011-01-12\")\nmdy(\"01/12/2011\")\ndmy(\"12jan2011\")\n```\n:::\n\n\nBut even more magical is that `lubridate`{.r} will automatically figure outthe format for you in many cases if you give it an ordered list of possible formats to try with the `parse_date_time`{.r} function.\n\n\n::: {.cell}\n```{webr}\nx <- c(\"2009-01-01\", \"02022010\", \"02-02-2010\")\nparse_date_time(x, c(\"dmY\", \"ymd\"))\n```\n:::\n\n\nRead more about `lubridate`{.r} in the [lubridate documentation](https://lubridate.tidyverse.org/).\n\n## Evaluation\n\nOK, a few exercises to make sure you understand these concepts.\n\n\n::: {.cell exercise='e1' setup='true'}\n```{webr}\n#| exercise: e1\n#| setup: true\nset.seed(596)\nesona <- esoph\nesona[sample(NROW(esona), 3), \"ncases\"] <- NA\nesona[sample(NROW(esona), 3), \"ncontrols\"] <- NA\n```\n:::\n\n\nFrom the `esona`{.r} `data.frame`{.r} created above, select the rows where \n`ncases`{.r} equals `3` but not `NA` (without using `subset`).\n\n\n::: {.cell exercise='e1' caption='Exercise 1'}\n```{webr}\n#| exercise: e1\n#| caption: Exercise 1\n```\n:::\n\n\n::: { .solution exercise=\"e1\" }\n\n::: {.cell exercise='e1' solution='true'}\n```{webr}\n#| exercise: e1\n#| solution: true\nesona[esona$ncases == 3 & !is.na(esona$ncases), ]\n```\n:::\n\n:::\n\n\n::: {.cell exercise='e1' check='true'}\n```{webr}\n#| exercise: e1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nFor regular expressions, `^` is used to represent the beginning of a \nstring and `$` is used to select the end of a string.  Use these to select\nthe words starting with \"b\" from the `words` vector above. \n\n\n::: {.cell exercise='e2' caption='Exercise 2' env='global'}\n```{webr}\n#| exercise: e2\n#| caption: Exercise 2\n#| env: global\n```\n:::\n\n\n::: { .solution exercise=\"e1\" }\n\n::: {.cell exercise='e2' solution='true'}\n```{webr}\n#| exercise: e2\n#| solution: true\ngrep(\"^b\", words, value = TRUE)\n```\n:::\n\n:::\n\n\n::: {.cell exercise='e2' check='true'}\n```{webr}\n#| exercise: e2\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nNow, try to get only those words that end with \"s\".\n\n\n::: {.cell exercise='e3' caption='Exercise 3' env='global'}\n```{webr}\n#| exercise: e3\n#| caption: Exercise 3\n#| env: global\n```\n:::\n\n\n::: { .solution exercise=\"e1\" }\n\n::: {.cell exercise='e3' solution='true'}\n```{webr}\n#| exercise: e3\n#| solution: true\ngrep(\"s$\", words, value = TRUE)\n```\n:::\n\n:::\n\n\n::: {.cell exercise='e3' check='true'}\n```{webr}\n#| exercise: e3\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\nPresuming that the string `\"12Oct1994\"` represents the \ndate October 12, 1994 using the `base` R package's `as.Date` function\nto convert that string to a date by using the correct format string \n(don't forget to look at the help file suggested above!).\n\n\n::: {.cell exercise='e4' caption='Exercise 4'}\n```{webr}\n#| exercise: e4\n#| caption: Exercise 4\n```\n:::\n\n\n::: { .hint exercise=\"e4\" }\nMake sure to read the help file for `strptime`{.r} to understand how to\nspecify date formats.\n\n\n::: {.cell}\n```{webr}\n?strptime\n```\n:::\n\n:::\n\n::: { .solution exercise=\"e4\" }\n\n::: {.cell exercise='e4' solution='true'}\n```{webr}\n#| exercise: e4\n#| solution: true\nas.Date(\"12Oct1994\", format=\"%d%b%Y\")\n```\n:::\n\n:::\n\n\n::: {.cell exercise='e4' check='true'}\n```{webr}\n#| exercise: e4\n#| check: true\ngradethis::grade_this(\n    if(as.Date(\"12Oct1994\", format=\"%d%b%Y\") == .result) {\n        pass()\n    } else {\n        fail(\"Check the hints if you are having trouble. {random_encouragement()}\")\n    }\n)\n```\n:::\n\n\nHow many days have you been alive? (Any reasonable date for your birthdate\nwill work.). Use `difftime` to calculate the result instead of functions\nin `lubridate` for the purposes of this exercise.\n\n\n::: {.cell exercise='e5' caption='Exercise 5'}\n```{webr}\n#| exercise: e5\n#| caption: Exercise 5\n```\n:::\n\n\n::: { .solution exercise=\"e5\" }\n\n::: {.cell exercise='e5' solution='true'}\n```{webr}\n#| exercise: e5\n#| solution: true\ndifftime(Sys.Date(), as.Date(\"2004-07-12\"), units=\"days\")\n```\n:::\n\n:::\n\n\n::: {.cell exercise='e5' check='true'}\n```{webr}\n#| exercise: e5\n#| check: true\ngradethis::grade_this(\n    if(.result < 0) {\n        fail(\"Are you substracting the dates in the right order?\")\n    } else if(.result > difftime(\"1997-08-04\", \"1875-02-21\", units=\"days\")) {\n        fail(\"Contact the Guinness Book of World Records! See [Jeanne Calment](https://en.wikipedia.org/wiki/Jeanne_Calment) for the longest verified human lifespan.\")\n    } else if(parse(text = .user_code)[[1]][[2]] != \"Sys.Date()\") {\n        fail(\"Make sure you are using `Sys.Date()` to get today's date. Don't take a chance with hard coding today's date!\") }\n    else {\n        pass()\n    }\n)\n```\n:::\n\n\nOn your own, pick a data set of your own choosing (perhaps this \nis an opportunity to test drive the data you want to use for your\nfinal project?).  Use one of the text or date functions to do something \nyou feel is useful to your data and demostrate it in compiled `.qmd` file.\n\n### Submit Your Assignment\n\n\n::: {.cell type='progress-submit'}\n```{adm}\n#| type: progress-submit\n```\n:::\n\n::: {#adm-progress-submit}\n\n::: {.cell autorun='true'}\n```{webr}\n#| autorun: true\n.progress_submit(\"11-Delicacies\", 5)\n```\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}